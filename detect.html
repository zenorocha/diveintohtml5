<!DOCTYPE html>
<meta charset=utf-8>
<title>Detectando funcionalidade da HTML5 - Dive Into HTML5</title>
<!--[if lt IE 9]><script src=j/html5.js></script><![endif]-->
<link rel=alternate type=application/atom+xml href=https://github.com/diveintomark/diveintohtml5/commits/master.atom>
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 2}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=prefetch href=index.html>
<p>Você está aqui: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#detect>Dive Into <abbr>HTML5</abbr></a> <span class=u>&#8227;</span>
<h1><br>Detectando funcionalidades da <abbr>HTML5</abbr></h1>
<p id=toc>&nbsp;
<p class=a>&#x2767;
<h2 id=divingin>Mergulhando</h2>

<p class=f><img src=i/aoc-v.png alt=V width=109 height=105>ocê pode se perguntar: &#8220;Como eu posso começar a usar <abbr>HTML5</abbr> se os navegadores não o suportam?&#8221; Mas a questão por si só é enganosa. <abbr>HTML5</abbr> não é uma coisa grande e única; é uma coleção de funcionalidades individuais. Então você não pode detectar &#8220;suporte ao <abbr>HTML5</abbr>,&#8221; por que isso não faz sentido. Mas você <em>pode</em> verificar o suporte a funcionalidades individuais, como canvas, video, ou geolocalização.

<p class=a>&#x2767;

<h2 id=techniques>Técnicas de detecção</h2>

<p>Quando seu navegador renderiza uma página web, ele constrói um Modelo Objeto Documento (<abbr><dfn>DOM</dfn></abbr>, Document Object Model em inglês), uma coleção de objetos que representam os elementos <abbr>HTML</abbr> na página. Cada elemento &mdash; todo <code>&lt;p></code>, todo <code>&lt;div></code>, todo <code>&lt;span></code> &mdash; é representado no <abbr>DOM</abbr> por um objeto diferente. (Também existem objetos globais, como <code>window</code> e <code>document</code>, que não estão vinculado a elementos específicos.)

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_peeking_out_the_window.png width=257 height=436 alt="girl peeking out the window">

<p>Todos os objetos no <abbr>DOM</abbr> compartilham um conjunto comum de propriedades, mas alguns objetos têm mais do que outros. Em navegadores que suportam funcionalidades da <abbr>HTML5</abbr>, alguns objetos terão propriedades únicas. Uma espiada rápida no <abbr>DOM</abbr> irá te dizer quais funcionalidades são suportadas.

<p>Existem quatros técnicas básicas para detectar se o browser suporta uma funcionalidade específica. Do mais simples até o mais complexo:

<ol>
<li>
<p>Verifica se uma determinada propriedade existe em um objeto global (como <code>window</code> ou <code>navigator</code>).
<p>Exemplo: <a href=#geolocation>testando o suporte a geolocalização</a>
<li>
<p>Crie um elemento, então verifique se uma determinada propriedade existe naquele elemento.
<p>Exemplo: <a href=#canvas>testanto suporte ao canvas</a>
<li>
<p>Crie um elemento, verifique se um determinado método existe naquele elemento, então chame o método e verifique o valor que ele retorna.
<p>Exemplo: <a href=#video-formats>testando quais formatos de vídeos são suportados</a>
<li>
<p>Crie um elemento, defina uma propriedade para um determinado valor, então verifique se a propriedade manteve seu valor.
<p>Exemplo: <a href=#input-types>testando quais tipos de <code>&lt;input></code> são suportados</a>
</ol>

<p class=a>&#x2767;

<h2 id=modernizr>Modernizr, uma biblioteca de detecção HTML5</h2>

<p><a href=http://www.modernizr.com/>Modernizr</a> é um biblioteca Javascript de código aberto, sob licença <abbr>MIT</abbr>, que detecta suporte a várias funcionalidades de <abbr>HTML5</abbr> <i class=baa>&amp;</i> <abbr>CSS3</abbr>. Você deve usar sempre a última versão. Para usá-la, inclua o seguinte elemento <code>&lt;script></code> no topo da sua página.

<pre style="float:left"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Dive Into HTML5&lt;/title>
  <mark>&lt;script src="modernizr.min.js">&lt;/script></mark>
&lt;/head>
&lt;body>
  ...
&lt;/body>
&lt;/html>
</code></pre>
<p class="legend right" style="margin-top:7em"><span class=arrow>&nbsp;&#x219c;</span> Isso vai no seu &lt;head>

<p class=clear>Modernizr executa automaticamente. Não existe uma função <code>modernizr_init()</code> para ser chamada. Quando ela roda, cria um objeto global chamado <code>Modernizr</code>, que contém um conjunto de propriedades Booleanas para cada funcionalidade que ela puder detectar. Por exemplo, se seu navegador suporta a <a href=canvas.html><abbr>API</abbr> do canvas</a>, a propriedade <code>Modernizr.canvas</code> será <code>true</code>. Se seu navagador não suportar a <abbr>API</abbr> do canvas, a propriedade <code>Modernizr.canvas</code> será <code>false</code>.

<pre><code>if (Modernizr.canvas) {
  // vamos desenhar algumas formas!
} else {
  // o suporte nativo ao canvas não está disponível :(
}</code></pre>

<p class=a>&#x2767;

<h2 id=canvas>Canvas</h2>

<p class=ss style="width:300px"><img src=i/openclipart.org_johnny_automatic_fishing_boat.png width=300 height=203 alt="man fishing in a canoe"><br><span id=live-canvas></span>

<p>A <abbr>HTML5</abbr> define <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>o elemento &lt;canvas> </a> como &#8220;uma tela bitmap de resolução dependente que pode ser usada para renderizar grafos, gráficos de jogos, ou outras imagens visuais em tempo real.&#8221; Um <dfn>canvas</dfn> é um retângulo na sua página onde você pode usar Javascript para desenhar qualquer coisa que você quiser. A <abbr>HTML5</abbr> define um conjunto de funções (&#8220;a <abbr>API</abbr> canvas&#8221;) para desenhar formas, definindo caminhos, criando gradientes e aplicando transformações.

<p>A verificação da <abbr>API</abbr> do canvas usa a <a href=#techniques>técnica de detecção #2</a>. Se seu navegador suporta a <abbr>API</abbr> do canvas, o objeto <abbr>DOM</abbr> o cria para representar um elemento <code>&lt;canvas></code> que terá um <a href=canvas.html#shapes>método <code>getContext()</code></a>. Se seu navegador não suporta a <abbr>API</abbr> do canvas, o objeto <abbr>DOM</abbr> o cria  para um elemento <code>&lt;canvas></code> que terá apenas um conjunto comum de propriedades, mas nada específico do canvas.

<pre><code>function supports_canvas() {
  return !!document.createElement('canvas').getContext;
}
</code></pre>

<p>Essa função começa com a criação de elemento <code>&lt;canvas></code> de teste. Mas o elemento nunca é adicionado a sua página, então ninguém nunca o verá. Está apenas flutuando na memória, indo a lugar nenhum e fazendo nada, como uma canoa em um rio calmo.

<pre><code>return !!document.<mark>createElement('canvas')</mark>.getContext;</code></pre>

<p>Asssim que você cria o elemento <code>&lt;canvas></code> de teste, você testa a existência de um método <code>getContext()</code>. Esse método só existirá se o seu navegador suportar a <abbr>API</abbr> do canvas.

<pre><code>return !!document.createElement('canvas').<mark>getContext</mark>;</code></pre>

<p>Finalmente, você usa o truque da negação dupla para forçar a conversão do resultado em um valor booleano(<code>true</code> ou <code>false</code>).

<pre><code>return <mark>!!</mark>document.createElement('canvas').getContext;</code></pre>

<p>Essa função irá detectar para grande parte da <abbr>API</abbr> do canvas, incluindo <a href=canvas.html#shapes>shapes</a>, <a href=canvas.html#paths>paths</a>, <a href=canvas.html#gradients>gradients <i class=baa>&amp;</i> patterns</a>. Ela não detectará a biblioteca de terceiros <a href=canvas.html#ie><code>explorercanvas</code></a> que implementa a <abbr>API</abbr> do canvas no Microsoft Internet Explorer.

<p>Ao invés de escrever essa função você mesmo, você pode usar a <a href=#modernizr>Modernizr</a> para detectar o suporte a <abbr>API</abbr> do canvas.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verifica o suporte ao canvas
<pre><code>if (<mark>Modernizr.canvas</mark>) {
  // vamos desenhar algumas formas!
} else {
  // o suporte nativo ao canvas não está disponível :(
}</code></pre>

<p>Existe um teste separado para a <abbr>API</abbr> do canvas text, que será demonstrado a seguir.

<p class=a>&#x2767;

<h2 id=canvas-text>Texto Canvas</h2>

<p class=ss style="width:414px"><img src=i/openclipart.org_johnny_automatic_baseball_at_bat.png width=414 height=254 alt="baseball player at bat"><br><span id=live-canvas-text></span>

<p>Mesmo que o seu navegador suporte a <a href=#canvas><abbr>API</abbr> canvas</a>, ele pode não suportar a <abbr>API</abbr> do <dfn>texto canvas</dfn>. A <abbr>API</abbr> do canvas cresceu através do tempo, e as funções de texto foram adicionadas por último. Alguns navegadores passaram a suportar o canvas antes da <abbr>API</abbr> de texto estar completa.

<p>A verificação da <abbr>API</abbr> do texto canvas usa a <a href=#techniques>técnica de detecção #2</a>. Se seu navegador suporta a <abbr>API</abbr> do canvas, o objeto <abbr>DOM</abbr> o cria para representar um elemento <code>&lt;canvas></code> que terá um <a href=canvas.html#shapes>método <code>getContext()</code></a>. Se seu navegador não suporta a <abbr>API</abbr> do canvas, o objeto <abbr>DOM</abbr> o cria  para um elemento <code>&lt;canvas></code> que terá apenas um conjunto comum de propriedades, mas nada específico do canvas.

<pre><code>function supports_canvas_text() {
  if (!supports_canvas()) { return false; }
  var dummy_canvas = document.createElement('canvas');
  var context = dummy_canvas.getContext('2d');
  return typeof context.fillText == 'function';
}</code></pre>

<p>A função começa <a href=#canvas>verificando o suporte ao canvas</a>, usando a função <code>supports_canvas()</code> que você acabou de ver na seção anterior. Se seu navegador não suporta a <abbr>API</abbr> do canvas, ele certamente não suportará a <abbr>API</abbr> de texto canvas!

<pre><code>if (<mark>!supports_canvas()</mark>) { return false; }</code></pre>

<p>Depois, você cria um elemento <code>&lt;canvas></code> de teste e pega seu contexto de desenho. Isso funcionará de forma garantida, porque a função <code>supports_canvas()</code> já verificou que o método <code>getContext()</code> existe em todo objeto canvas.

<pre><code>  var dummy_canvas = document.createElement('canvas');
  var context = <mark>dummy_canvas.getContext('2d')</mark>;</code></pre>

<p>Finalmente, você verifica se o contexto de desenho tem uma função <code>fillText()</code>. Se tiver, a <abbr>API</abbr> de texto canvas está disponível. Hooray!

<pre><code>  return <mark>typeof context.fillText == 'function'</mark>;</code></pre>

<p>Ao invés de escrever essa função você mesmo, você pode usar <a href=#modernizr>Modernizr</a> para detectar o suporte à <abbr>API</abbr> do texto canvas.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verifica o suporte ao texto canvas
<pre><code>if (<mark>Modernizr.canvastext</mark>) {
  // vamos desenhar algum texto!
} else {
  // sem suporte nativo ao texto canvas disponível :(
}</code></pre>

<p class=a>&#x2767;

<h2 id=video>Vídeo</h2>
<p>A <abbr>HTML5</abbr> define um novo elemento chamado <code>&lt;video></code> para embutir vídeo nas suas páginas web. Embutir vídeos costuma ser impossível sem plugins de terceiros como Apple QuickTime&reg; ou Adobe Flash&reg;.

<p class=ss style="width:224px"><img src=i/openclipart.org_johnny_automatic_at_the_theater.png alt="audience at the theater" width=224 height=334><br><span id=live-video></span>

<p>O elemento <code>&lt;video></code> é projetado para funcionar sem a necessidade de scripts de detecção. Você pode especificar múltiplos arquivos de vídeo, e os navegadores que possuirem suporte ao <abbr>HTML5</abbr> vídeo escolherão um baseado nos formatos suportados por eles. (See &#8220;A gentle introduction to video encoding&#8221; <a href=http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats>part 1: container formats</a> and <a href=http://diveintomark.org/archives/2008/12/19/give-part-2-lossy-video-codecs>part 2: lossy video codecs</a> to learn about different video formats.)

<p>Navegadores que não possuem suporte a <abbr>HTML5</abbr> vídeo irão ignorar o elemento <code>&lt;video></code> completamente, mas você pode usar isso a seu favor dizendo a eles para tocar o vídeo através de plugins. Kroc Camen desenvolveu uma solução chamada <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a> que faz uso da <abbr>HTML5</abbr> vídeo onde estiver disponivel, porém fazendo tratamento para uso de QuickTime ou Flash em navegadores antigos. Essa solução não usa Javascript, e funciona praticamente em qualquer navegador, inclusive em mobiles.

<p>Se você quiser fazer mais com vídeo do que apenas colocá-lo em sua página e tocá-lo, terá que usar Javascript. Checar suporte a vídeo utiliza a <a href=#techniques>técnica e detecção #2</a>. Se seu navegador possui suporte para <abbr>HTML5</abbr> vídeo, o objeto <abbr>DOM</abbr> criado para representar o elemento <code>&lt;video></code> terá um método <code>canPlayType()</code>. Caso o navegador não tenha suporte para <abbr>HTML5</abbr> vídeo, o objeto <abbr>DOM</abbr> criado para o elemento <code>&lt;video></code> terá apenas uma coleção de proprieades comum à todos os elementos. Você pode verificar o suporte a vídeo usando essa função:

<pre><code>function supports_video() {
  return !!document.createElement('video').canPlayType;
}</code></pre>

<p>Ao invés de escrever a função você mesmo, você pode usar o <a href=#modernizr>Modernizr</a> para detectar suporte a <abbr>HTML5</abbr> vídeo.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte a <abbr>HTML5</abbr> vídeo
<pre><code>if (<mark>Modernizr.video</mark>) {
  // vamos tocar alguns vídeos!
} else {
  // suporte nativo a vídeos indisponível :(
  // verifique suporte a QuickTime ou Flash talvez
}</code></pre>

<p>No <a href=video.html>capítulo de Vídeo</a>, explicarei outra solução que faz uso dessas técnicas de detecção para converter elementos <code>&lt;video></code> para players baseados em Flash, para atender a navegadores que não possuem suporte ao <abbr>HTML5</abbr> vídeo.

<p>Existe um teste separado para detectar quais formatos de vídeo seu navegador pode tocar, o qual demonstrarei em seguida.

<p class=a>&#x2767;

<h2 id=video-formats>Formatos de Vídeo</h2>

<p>Formatos de vídeo são como linguagens escritas. Um jornal em inglês contém a mesma informação que um jornal em espanhol, mas se você só sabe ler inglês, apenas um dos jornais será útil pra você! Para tocar um vídeo, seu navegador precisa entender o &#8220;idioma&#8221; no qual o vídeo foi escrito.

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:250px"><img src=i/openclipart.org_johnny_automatic_man_reading_newspaper.png alt="man reading newspaper" width=250 height=261><br><span id=live-video-formats></span>

<p>O &#8220;idioma&#8221; de um vídeo é chamado de &#8220;codec&#8221; &mdash; é um algoritmo usado para codificar o vídeo em uma sequência de bits. Existem vários codecs em uso ao redor do mundo. Qual deles você usa? A triste realidade da <abbr>HTML5</abbr> vídeo é que os navegadores não trabalham com um único codec em comum. Contudo, aparentemente eles se limitaram a dois tipos. Um codec é pago (por causa da licença de patente), mas funciona no <a href=http://www.apple.com/safari/>Safari</a> e no iPhone. (Este também funciona com Flash se você utiliza uma solução como <a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a>) O outro codec é gratuito e funciona em navegadores open source como <a href=http://code.google.com/chromium/>Chromium</a> and <a href=http://www.getfirefox.com/>Mozilla Firefox</a>.

<p>A verificação de suporte a formatos de vídeo utiliza a <a href=#techniques>técnica de detecção #3</a>. Se o seu navegador possui suporte a <abbr>HTML5</abbr> vídeo, o objeto <abbr>DOM</abbr> criado para representar um elemento <code>&lt;video></code> terá um método <code>canPlayType()</code>. Esse método dirá se seu browser possui suporte a um determinado formato de vídeo.

<p>Essa função verifica formatos suportados por Macs e iPhones.

<pre><code>function supports_h264_baseline_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
}</code></pre>

<p>A função começa <a href=#video>verificando suporte a <abbr>HTML5</abbr> vídeo</a>, usando ao função <code>supports_video()</code> que você acabou de ver na seção anterior. Se o seu navegador não possui suporte a  <abbr>HTML5</abbr> vídeo, com certeza não terá suporte para formatos de vídeo!

<pre><code>  if (<mark>!supports_video()</mark>) { return false; }</code></pre>

<p>Então a função cria um elemento <code>&lt;video></code> (mas não o inclui na página, assim ele não será visível) e invoca o método <code>canPlayType()</code>. Este método está lá seguramente, pois a função <code>supports_video()</code> acabou de garantir sua existência.

<pre><code>  var <mark>v</mark> = document.createElement("video");</code></pre>

<p>Um &#8220;formato de vídeo&#8221; é na verdade uma combinação de diferentes coisas. Em termos técnicos, vocês está perguntando ao navegador se ele pode tocar um vídeo de base H.264 e um áudio AAC LC em um container MPEG-4. (Irei explicar o que tudo isso significa no  <a href=video.html>capítulo de Vídeo</a>. Você também pode querer ler <a href=http://diveintomark.org/tag/give>Uma breve introdução à codificação de vídeo</a>.)

<pre><code>  return v.canPlayType('<mark>video/mp4; codecs="avc1.42E01E, mp4a.40.2"</mark>');</code></pre>

<p>A função <code>canPlayType()</code> não retorna <code>true</code> ou <code>false</code>. Considerando a complexidade que os formatos de vídeo possuem, a função retorna uma string:

<ul>
<li><code>"probably"</code> se o navegador está pouco confiante de que possa tocar este formato
<li><code>"maybe"</code> se o navegador acha que tem condições de tocar este formato
<li><code>""</code> (uma string vazia) se o navegador tem certeza de que não consegue tocar este formato
</ul>

<p>Essa segunda função verifica pelo formato de vídeo livre suportado pelo Mozilla Firefox e outros navegadores de código aberto. O processo é exatamente o mesmo; a única diferença é a string que você passa à função <code>canPlayType()</code>. Em termos técnicos, você pergunta ao navegador se ele é capaz de tocar vídeo Theora e áudio Vorbis em um container Ogg.

<pre><code>function supports_ogg_theora_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType(<mark>'video/ogg; codecs="theora, vorbis"'</mark>);
}</code></pre>

<p>Finalmente, <a href=http://www.webmproject.org/>WebM</a> é um recente codec de vídeo open-source (e livre de patentes) que será incluido nas próximas versões dos principais navegadores, tais como o Chrome, <a href=http://nightly.mozilla.org/webm/>Firefox</a>, e <a href=http://labs.opera.com/news/2010/05/19/>Opera</a>. Você pode utilizar a mesma técnica para detectar suporte ao vídeo livre WebM.

<pre><code>function supports_webm_video() {
  if (!supports_video()) { return false; }
  var v = document.createElement("video");
  return v.canPlayType(<mark>'video/webm; codecs="vp8, vorbis"'</mark>);
}</code></pre>

<p>Ao invés de escrever essa função você mesmo, você pode utilizar o <a href=#modernizr>Modernizr</a> (1.5 ou superior) para detectar suporte aos diferentes formatos de <abbr>HTML5</abbr> vídeo.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte a formatos para <abbr>HTML5</abbr> vídeo
<pre><code>if (Modernizr.video) {
  // vamos tocar alguns vídeos! mas de qual tipo?
  if (<mark>Modernizr.video.webm</mark>) {
    // tentar o WebM
  } else if (<mark>Modernizr.video.ogg</mark>) {
    // tentar Ogg Theora + Vorbis em um container Ogg
  } else if (<mark>Modernizr.video.h264</mark>){
    // tentar vídeo H.264 + áudio AAC em um container MP4
  }
}</code></pre>

<p class=a>&#x2767;

<h2 id=storage>Armazenamento Local</h2>

<p class=ss style="width:135px"><img src=i/openclipart.org_johnny_automatic_half_stack_of_horizontal_sections.png alt="filing cabinet with drawers of different sizes" width=135 height=341><br><span id=live-storage></span>

<p><a href=http://dev.w3.org/html5/webstorage/><abbr>HTML5</abbr> storage</a> fornece aos web sites uma forma de armazenar informações em seu computador e recuperá-lo mais tarde. O conceito é semelhante ao dos cookies, porém ele é projetado para armazenar quantidades de informação superiores. Cookies possuem tamanho bem limitado, e o seu navegador os envia de volta ao servidor web sempre que uma nova página é solicitada (o que leva um tempo extra e uma banda valiosa). O <abbr>HTML5</abbr> storage permanece em seu computador, e os web sites podem acessá-lo através de Javascript depois que a página é carregada.

<div class="pf clear">
<h4>Pergunte ao Professor Marcação</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>P: O armazenamento local é realmente parte da <abbr>HTML5</abbr>? Por que ele fica em uma especificação separada?<br>
R: A resposta curta é sim, armazenamento local é parte da <abbr>HTML5</abbr>. A resposta um pouco mais completa é que o armazenamento local fazia parte da especificação principal da <abbr>HTML5</abbr>, mas foi dividido em uma especificação isolada porque algumas pessoas no Working Group da <abbr>HTML5</abbr> se queixaram que a <abbr>HTML5</abbr> estava ficando muito grande. Se partir um bolo em mais pedaços passa a sensação de reduzir o número de calorias, bem, bem vindo ao mundo estranho dos padrões.
</blockquote>
</div>
</div>

<p>A verificação de suporte ao <abbr>HTML5</abbr> storage utiliza a <a href=#techniques>técnica de detecção #1</a>. Se o seu navegador possui suporte ao <abbr>HTML5</abbr> storage, haverá uma propriedade chamada <code>localStorage</code> no objeto global <code>window</code>. Se o seu navegador não possui suporte ao <abbr>HTML5</abbr> storage, a propriedade <code>localStorage</code> será undefined. Devido a um bug em versões anteriores do Firefox, este teste causará uma exceção se os cookies estiverem desabilitados, por isso o teste todo é envolvido por um bloco  <code>try..catch</code>.

<pre><code>function supports_local_storage() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  } catch(e){
    return false;
  }
}</code></pre>

<p>Ao invés de escrever essa função, você pode usar o <a href=#modernizr>Modernizr</a> (1.1 ou superior) para detectar suporte ao <abbr>HTML5</abbr> local storage.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte ao <abbr>HTML5</abbr> local storage
<pre><code>if (<mark>Modernizr.localstorage</mark>) {
  // window.localStorage está disponível!
} else {
  // sem suporte nativo ao local storage :(
  // tente usar o Gears ou outra solução, talvez
}</code></pre>

<p>Note que o Javascript faz distinção entre letras maiúsculas e minúsculas. O atributo do Modernizr é chamado <code>localstorage</code> (todas as letras minúsculas), mas a propriedade <abbr>DOM</abbr> é chamada <code>window.localStorage</code> (letras maiúsculas e minúsculas misturadas).

<div class="pf clear">
<h4>Pergunte ao Professor Marcação</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>P: Quão seguro é o banco de dados da <abbr>HTML5</abbr> storage? Qualquer um pode acessá-lo?<br>
R: Qualquer um que possua acesso físico ao seu computador provavelmente poderá ler (ou até mesmo editar) seu banco de dados da <abbr>HTML5</abbr> storage. Com seu navegador, qualquer web site pode ler e modificar seus próprios valores, mas sites não podem acessar valores armazenados por outros sites. Isso é chamado de <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#origin-0>same-origin restriction</a>.
</blockquote>
</div>
</div>

<p class=a>&#x2767;

<h2 id=workers>Web Workers</h2>

<p class=ss style="margin:1.75em"><span id=live-web-workers></span>

<p><a href=http://www.whatwg.org/specs/web-workers/current-work/>Web Workers</a> fornecem uma maneira padrão aos navegadores de executarem Javascript ao fundo. Com web workers, você pode disparar múltiplas &#8220;threads&#8221; que irão todas ser executadas ao mesmo tempo, mais ou menos. (Pense em como o computador pode executar múltiplas aplicações ao mesmo tempo e você terá praticamente entendido tudo.) Essas &#8220;threads em background&#8221; podem realizar cálculos matemáticos complexos, fazer requisições HTTP ou acessar o <a href=#local-storage>local storage</a> enquanto a página principal atende aos comandos do usuário tais como rolando a página, cliques ou digitação.

<p>Verificar o suporte às web workers utiliza a <a href=#techniques>técnica de detecção #1</a>. Se o seu navegador possui suporte à <abbr>API</abbr> do Web Worker, haverá uma propriedade <code>Worker</code> no objeto global <code>window</code>. Se o seu navegador não possui suporte à <abbr>API</abbr> do Web Worker, a propriedade <code>Worker</code> será undefined.

<pre><code>function supports_web_workers() {
  return !!window.Worker;
}</code></pre>

<p>Ao invés de escrever essa função, você pode utilizar o <a href=#modernizr>Modernizr</a> (1.1 ou superior) para detectar suporte a web workers.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte a web workers
<pre><code>if (<mark>Modernizr.webworkers</mark>) {
  // window.Worker está disponível!
} else {
  // sem suporte nativo a web workers :(
  // tente o Gears ou outra solução
}</code></pre>

<p>Note que o Javascript faz distinção entre letras maiúsculas e minúsculas. O atributo do Modernizr é chamado <code>webworkers</code> (todas as letras minúsculas), mas a propriedade <abbr>DOM</abbr> é chamada <code>window.Worker</code> (letras maiúsculas e minúsculas misturadas).

<p class=a>&#x2767;

<h2 id=offline>Aplicações Web Offline</h2>

<p class=ss style="width:257px"><img src=i/openclipart.org_johnny_automatic_cabin_along_stream.png alt="cabin in the woods" width=257 height=242><br><span id=live-offline></span>

<p>Ler páginas web estáticas é fácil: conecte-se na Internet, carregue uma página, se disconecte da Internet, dirija até uma cabine isolada, e leia a página comodamente. (Para ganhar tempo, pule a parte de ir até uma cabine.) Mas e as aplicações como o <a href=http://mail.google.com/>Gmail</a> ou <a href=http://docs.google.com/>Google Docs</a>? Graças ao <abbr>HTML5</abbr>, qualquer um (não só o Google!) pode construir uma aplicação web que funcione offline.

<p><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline>Aplicações web offline</a> começam como aplicações web online. A primeira vez que você visita um site com conteúdo offline habilitado, o servidor web diz ao navegador quais arquivos ele precisa para trabalhar offline. Esses arquivos podem ser qualquer coisa &mdash; <abbr>HTML</abbr>, JavaScript, imagens, até mesmo <a href=#video>vídeos</a>. Uma vez que o navegador carregou todos os arquivos necessários, você pode revisitar o web site até mesmo se você não estiver conectado a Internet. Seu navegador perceberá que você está offline e usará os arquivos que ele já havia feito download. Quando você se reconectar, quaisquer alterações que você tenha feito podem ser enviadas ao servidor web.

<p>Verificar o suporte conteúdo offline utiliza a <a href=#techniques>técnica de detecção #1</a>. Se o seu navegador possui suporte à aplicações web offline, haverá uma propriedade <code>applicationCache</code> no objeto global <code>window</code>. Se o seu navegador não possui suporte à aplicações web offline, a propriedade <code>applicationCache</code> será undefined. Você pode verificar a disponibilidade de aplicações web offline através da seguinte função:

<pre><code>function supports_offline() {
  return !!window.applicationCache;
}</code></pre>

<p>Ao invés de escrever essa função, você pode utilizar o <a href=#modernizr>Modernizr</a> (1.1 ou superior) para detectar suporte a aplicações web offline.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte a aplicações web offline
<pre><code>if (<mark>Modernizr.applicationcache</mark>) {
  // window.applicationCache está disponível!
} else {
  // sem suporte nativo a conteudo offline :(
  // tente usar o Gears ou outra solução
}</code></pre>

<p>Note que o Javascript faz distinção entre letras maiúsculas e minúsculas. O atributo do Modernizr é chamado <code>applicationcache</code> (todas as letras minúsculas), mas a propriedade <abbr>DOM</abbr> é chamada <code>window.applicationCache</code> (letras maiúsculas e minúsculas misturadas).

<p class=a>&#x2767;

<h2 id=geolocation>Geolocalização</h2>

<p>Geolocalização é a arte de descobrir em que lugar do mundo você está e (eventualmente) compartilhar essa informação com as pessoas de sua confiança. Existe mais de uma maneira de saber onde você está &mdash; seu endereço <abbr>IP</abbr>, sua conexão de rede sem fio, com qual torre seu celular está se comunicando, ou o <abbr>GPS</abbr> que calcula a latitude e longitude através das informações enviadas pelos satélites no céu.

<p style="margin:0 auto;width:194px" id=geo-wrapper><img src=i/openclipart.org_johnny_automatic_globe_man.png alt="man with a globe for a head" width=194 height=317><br><span id=live-geolocation></span>

<div class="pf clear">
<h4>Pergunte ao Professor Marcação</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>P: A geolocalização faz parte da <abbr>HTML5</abbr>? Por que você está falando sobre ela?<br>
R: O suporte a geolocalização foi adicionado aos navegadores agora há pouco, juntamente com o suporte para novos recursos <abbr>HTML5</abbr>. Na verdade, a geolocalização está sendo padronizada pelo <a href=http://www.w3.org/2008/geolocation/>Geolocation Working Group</a>, o qual está separado da <abbr>HTML5</abbr> Working Group. Porém eu irei falar sobre a geolocalização neste livro assim mesmo, porque ela é parte da evolução da web que está acontecendo nesse momento.
</blockquote>
</div>
</div>

<p>Verificar o suporte à geolocalização utiliza a <a href=#techniques>técnica de detecção #1</a>. Se o seu navegador possui suporte à geolocalização, haverá uma propriedade <code>geolocation</code> no objeto global <code>window</code>. Se o seu navegador não possui suporte à geolocalização, a propriedade <code>geolocation</code> será undefined. Veja como você pode verificar se há suporte à geolocalização:

<pre><code>function supports_geolocation() {
  return !!navigator.geolocation;
}</code></pre>

<p>Ao invés de escrever essa função, você pode utilizar o <a href=#modernizr>Modernizr</a> para detectar suporte a <abbr>API</abbr> da geolocalização.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte a geolocalização
<pre><code>if (<mark>Modernizr.geolocation</mark>) {
  // Vamos ver onde você está!
} else {
  // suporte nativo à geolocalizaçãono indisponível :(
  // tente o Gears ou outra solução
}</code></pre>

<p>Se o seu navegador não possui suporte nativo à geolocalização, ainda há esperança. O <a href=http://tools.google.com/gears/>Gears</a> é um plugin para navegadores livre desenvolvido pelo Google que funciona no Windows, Mac, Linux, Windows Mobile e Android. Ele fornece recursos para navegadores mais antigos que não possuem suporte a todas essas novas coisas estilosas que viemos discutindo neste capítulo. Um dos recursos que o Gears fornece é a <abbr>API</abbr> de geolocalização. Não é exatamente a mesma coisa que <code>navigator.geolocation</code>, mas funciona como se fosse.

<p>Existem ainda <abbr>API</abbr>s de geolocalização específicas para determinados dispositivos para alguns celulares antigos, incluindo <a href="http://www.tonybunce.com/2008/05/08/Blackberry-Browser-Amp-GPS.aspx">BlackBerry</a>, <a href="http://www.forum.nokia.com/infocenter/index.jsp?topic=/Web_Developers_Library/GUID-4DDE31C7-EC0D-4EEC-BC3A-A0B0351154F8.html">Nokia</a>, <a href="http://developer.palm.com/index.php?option=com_content&amp;view=article&amp;id=1673#GPS-getCurrentPosition">Palm</a> e <a href=http://bondi.omtp.org/1.0/apis/geolocation.html><abbr title="Open Mobile Terminal Platform">OMTP</abbr> BONDI</a>.

<p>O <a href=geolocation.html>capítulo sobre geolocalização</a> falará nos mínimos detalhes sobre como usar as diferentes <abbr>API</abbr>s.

<p class=a>&#x2767;

<h2 id=input-types>Tipos de entrada</h2>

<p class=ss style="width:261px"><img src=i/openclipart.org_johnny_automatic_typewriter.png alt="manual typewriter" width=261 height=228><br><span id=live-input-types></span>

<p>Você sabe tudo sobre formulários web, certo? Fazer um <code>&lt;form></code>, adicionar alguns elementos <code>&lt;input type="text"></code> e quem sabe um <code>&lt;input type="password"></code>, e por fim um botão <code>&lt;input type="submit"></code>.

<p>Você não sabe a metade deles. a <abbr>HTML5</abbr> define um monte de novos tipos de entrada de dados que você pode usar em seus formulários.

<ol>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#text-state-and-search-state><code>&lt;input type="search"></code></a> para caixas de busca
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#number-state><code>&lt;input type="number"></code></a> para campos incrementais
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#range-state><code>&lt;input type="range"></code></a> para sliders
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#color-state><code>&lt;input type="color"></code></a> para seleção de cores
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#telephone-state><code>&lt;input type="tel"></code></a> para números de telefone
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#url-state><code>&lt;input type="url"></code></a> para endereços na web
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state><code>&lt;input type="email"></code></a> para endereços de e-mail
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#date-state><code>&lt;input type="date"></code></a> para calendários
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#month-state><code>&lt;input type="month"></code></a> para meses
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#week-state><code>&lt;input type="week"></code></a> para semanas
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#time-state><code>&lt;input type="time"></code></a> para horas
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#date-and-time-state><code>&lt;input type="datetime"></code></a> para precisos e absolutos data+hora
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#local-date-and-time-state><code>&lt;input type="datetime-local"></code></a> para datas e horas locais
</ol>

<p>Verificando suporte ao tipos de entrada da <abbr>HTML5</abbr> utiliza a <a href=#techniques>técnica de detecção #4</a>. Primeiro, você cria um elemento <code>&lt;input></code> em memória. O tipo padrão para todos os elementos <code>&lt;input></code> é <code>"text"</code>. 

<pre><code>  var i = document.createElement("input");</code></pre>

<p>Em seguida, configure o atributo <code>type</code> ao elemento <code>&lt;input></code> para o tipo de entrada que você quer detectar.

<pre><code>  i.setAttribute("type", "color");</code></pre>

<p>Se o seu navegador possuir suporte para aquele tipo de entrada em particular, a propriedade <code>type</code> irá reter o valor que você configurou. Se o seu navegador não possuir suporte para aquele tipo de entrada em particular, ele irá ignorar o valor que você configurou e a propriedade <code>type</code> ainda será <code>"text"</code>.

<pre><code>  return i.type !== "text";</code></pre>

<p>Ao invés de ter de escrever 13 diferentes funções, você pode usar o <a href=#modernizr>Modernizr</a> para detectar suporte para todos os novos tipos de entrada definidos na <abbr>HTML5</abbr>. O Modernizr reaproveita um único elemento <code>&lt;input></code> para eficientemente detectar o suporte aos 13 tipos de entrada. Então ele constrói um hash chamado de <code>Modernizr.inputtypes</code>, que possui 13 chaves (os atributos <code>type</code> da <abbr>HTML5</abbr>) e 13 valores booleanos (<code>true</code> se for suportado, <code>false</code> se não).

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> verificando suporte nativo ao date picker
<pre><code>if (<mark>!Modernizr.inputtypes.date</mark>) {
  // sem suporte nativo para &lt;input type="date"> :(
  // talvez você deva fazer um você mesmo com <a href=http://docs.dojocampus.org/dojox/widget/Calendar>Dojo</a> ou <a href=http://jqueryui.com/demos/datepicker/>jQueryUI</a>
}</code></pre>

<p class=a>&#x2767;

<h2 id=input-placeholder>Placeholder</h2>

<form style="float:right;margin:1.75em"><input placeholder="Your browser supports placeholder text" size=38></form>

<p>Além dos <a href=#input-types>novos tipos de entrada</a>, a <abbr>HTML5</abbr> inclui vários pequenos ajustes aos formulários já existentes. Uma melhoria é colocar um <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/common-input-element-attributes.html#the-placeholder-attribute>placeholder em um campo de entrada</a>. O placeholder é exibido dentro de um campo de entrada enquanto o campo estiver vazio e sem foco. Assim que você clica no campo (ou navega com o tab até ele), o placeholder some. O <a href=forms.html#placeholder>capítulo sobre formulários web</a> tem screenshots se você está tendo dificuldades em visualizá-lo.

<p>A verificação de suporte ao placeholder utiliza a <a href=#techniques>técnica de detecção #2</a>. Se o seu navegador possui suporte à colocar placeholders em campos de entrada, o objeto <abbr>DOM</abbr> criado para representar o elemento <code>&lt;input></code> terá uma propriedade <code>placeholder</code> (mesmo que você não inclua um atributo <code>placeholder</code> em seu <abbr>HTML</abbr>). Se o seu navegador não possui suporte ao placeholder, o objeto <abbr>DOM</abbr> criado para um elemento <code>&lt;input></code> não terá uma propriedade <code>placeholder</code>.

<pre><code>function supports_input_placeholder() {
  var i = document.createElement('input');
  return 'placeholder' in i;
}</code></pre>

<p>Ao invés de escrever essa função, você pode utilizar o <a href=#modernizr>Modernizr</a> (1.1 ou superior) para detectar suporte ao placeholder.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> checa pelo texto de placeholder
<pre><code>if (<mark>Modernizr.input.placeholder</mark>) {
  // seu placeholder já deve estar visível!
} else {
  // sem suporte ao placeholder :(
  // implemente uma solução com script
}</code></pre>

<p class=a>&#x2767;

<h2 id=input-autofocus>Form Autofocus</h2>

<p class=ss style="width:188px"><img src=i/openclipart.org_johnny_automatic_angry_guy.png alt="angry guy with arms up" width=188 height=262><br><span id="live-input-autofocus"></span>

<p>Web sites can use JavaScript to focus the first input field of a web form automatically. For example, the home page of <a href=http://www.google.com/>Google.com</a> will autofocus the input box so you can type your search keywords without having to position the cursor in the search box. While this is convenient for most people, it can be annoying for power users or people with special needs. If you press the space bar expecting to scroll the page, the page will not scroll because the focus is already in a form input field. (It types a space in the field instead of scrolling.) If you focus a different input field while the page is still loading, the site&#8217;s autofocus script may &#8220;helpfully&#8221; move the focus back to the original input field upon completion, disrupting your flow and causing you to type in the wrong place.

<p>Because the autofocusing is done with JavaScript, it can be tricky to handle all of these edge cases, and there is little recourse for people who don&#8217;t want a web page to &#8220;steal&#8221; the focus.

<p>To solve this problem, <abbr>HTML5</abbr> introduces <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofocusing-a-form-control>an <code>autofocus</code> attribute on all web form controls</a>. The <code>autofocus</code> attribute does exactly what it says on the tin: it moves the focus to a particular input field. But because it&#8217;s just markup instead of a script, the behavior will be consistent across all web sites. Also, browser vendors (or extension authors) can offer users a way to disable the autofocusing behavior.

<p>Checking for autofocus support uses <a href=#techniques>detection technique #2</a>. If your browser supports autofocusing web form controls, the <abbr>DOM</abbr> object it creates to represent an <code>&lt;input></code> element will have an <code>autofocus</code> property (even if you don&#8217;t include the <code>autofocus</code> attribute in your <abbr>HTML</abbr>). If your browser doesn&#8217;t support autofocusing web form controls, the <abbr>DOM</abbr> object it creates for an <code>&lt;input></code> element will not have an <code>autofocus</code> property. You can detect autofocus support with this function:

<pre><code>function supports_input_autofocus() {
  var i = document.createElement('input');
  return 'autofocus' in i;
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.1 or later) to detect support for autofocused form fields.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for autofocus support
<pre><code>if (<mark>Modernizr.input.autofocus</mark>) {
  // autofocus works!
} else {
  // no autofocus support :(
  // fall back to a scripted solution
}</code></pre>

<p class=a>&#x2767;

<h2 id=microdata>Microdata</h2>

<p class=ss style="width:305px"><img src=i/openclipart.org_johnny_automatic_divider_cards.png alt="alphabetized folders" width=305 height=224><br><span id="live-microdata-api"></span>

<p><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#microdata>Microdata</a> is a standardized way to provide additional semantics in your web pages. For example, you can use microdata to declare that a photograph is available under a specific Creative Commons license. As you&#8217;ll see in <a href=extensibility.html>the distributed extensibility chapter</a>, you can use microdata to mark up an &#8220;About Me&#8221; page. Browsers, browser extensions, and search engines can convert your <abbr>HTML5</abbr> microdata markup into a <a href=http://en.wikipedia.org/wiki/VCard>vCard</a>, a standard format for sharing contact information. You can also define your own microdata vocabularies.

<p>The <abbr>HTML5</abbr> microdata standard includes both <abbr>HTML</abbr> markup (primarily for search engines) and a set of <abbr>DOM</abbr> functions (primarily for browsers). There&#8217;s no harm in including microdata markup in your web pages. It&#8217;s nothing more than a few well-placed attributes, and search engines that don&#8217;t understand the microdata attributes will just ignore them. But if you need to access or manipulate microdata through the <abbr>DOM</abbr>, you&#8217;ll need to check whether the browser supports the microdata <abbr>DOM</abbr> <abbr>API</abbr>.

<p>Checking for <abbr>HTML5</abbr> microdata <abbr>API</abbr> support uses <a href=#techniques>detection technique #1</a>. If your browser supports the <abbr>HTML5</abbr> microdata <abbr>API</abbr>, there will be a <code>getItems()</code> function on the global <code>document</code> object. If your browser doesn&#8217;t support microdata, the <code>getItems()</code> function will be undefined.

<pre><code>function supports_microdata_api() {
  return !!document.getItems;
}</code></pre>

<p>Modernizr does not yet support checking for the microdata <abbr>API</abbr>, so you&#8217;ll need to use the function like the one listed above.

<p class=a>&#x2767;

<h2 id=history>History <abbr>API</abbr></h2>

<p class=ss style="float:left;margin:0 1.75em 1.75em 0;width:218px"><img src=i/openclipart.org_johnny_automatic_demon_reading_Stewart_Orr.png alt="demon reading book" width=218 height=231><br><span id=live-history-api></span>

<p>The <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html><abbr>HTML5</abbr> history <abbr>API</abbr></a> is a standardized way to manipulate the browser history via script. Part of this <abbr>API</abbr> &mdash; navigating the history &mdash; has been available in previous versions of <abbr>HTML</abbr>. The new part in <abbr>HTML5</abbr> is a way to add entries to the browser history, and respond when those entries are removed from the stack by the user pressing the browser&#8217;s back button. This means that the <abbr>URL</abbr> can continue to do its job as a unique identifier for the current resource, even in script-heavy applications that don&#8217;t ever perform a full page refresh.

<p>Checking for <abbr>HTML5</abbr> history <abbr>API</abbr> support uses <a href=#techniques>detection technique #1</a>. If your browser supports the <abbr>HTML5</abbr> history <abbr>API</abbr>, there will be a <code>pushState()</code> function on the global <code>history</code> object. If your browser doesn&#8217;t support the history <abbr>API</abbr>, the <code>pushState()</code> function will be undefined.

<pre><code>function supports_history_api() {
  return !!(window.history && history.pushState);
}</code></pre>

<p>Instead of writing this function yourself, you can use <a href=#modernizr>Modernizr</a> (1.6 or later) to detect support for the <abbr>HTML5</abbr> history <abbr>API</abbr>.

<p class="legend top" style="padding-left:6em"><span class=arrow>&#x21b6;</span> check for history <abbr>API</abbr> support
<pre><code>if (<mark>Modernizr.history</mark>) {
  // history management works!
} else {
  // no history support :(
  // fall back to a scripted solution like <a href=https://github.com/balupton/History.js/>History.js</a>
}</code></pre>

<p class=a>&#x2767;

<h2 id=further-reading>Further Reading</h2>

<p>Specifications and standards:

<ul>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>the <code>&lt;canvas></code> element</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#video>the <code>&lt;video></code> element</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#states-of-the-type-attribute><code>&lt;input></code> types</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/common-input-element-attributes.html#the-placeholder-attribute>the <code>&lt;input placeholder></code> attribute</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofocusing-a-form-control>the <code>&lt;input autofocus></code> attribute</a>
<li><a href=http://dev.w3.org/html5/webstorage/><abbr>HTML5</abbr> storage</a>
<li><a href=http://www.whatwg.org/specs/web-workers/current-work/>Web Workers</a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline>Offline web applications</a>
<li><a href=http://www.w3.org/TR/geolocation-API/>Geolocation <abbr>API</abbr></a>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html>Session history and navigation</a>
</ul>

<p>JavaScript libraries:

<ul>
<li><a href=http://www.modernizr.com/>Modernizr</a>, an <abbr>HTML5</abbr> detection library
<li><a href=http://code.google.com/p/geo-location-javascript/>geo.js</a>, a geolocation <abbr>API</abbr> wrapper
<li><a href=https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills><abbr>HTML5</abbr> Cross-browser Polyfills</a>
</ul>

<p>Other articles and tutorials:

<ul>
<li><a href=http://camendesign.com/code/video_for_everybody>Video for Everybody!</a>
<li><a href=http://diveintomark.org/tag/give>A gentle introduction to video encoding</a>
<li><a href=http://wiki.whatwg.org/wiki/Video_type_parameters>Video type parameters</a>
<li><a href=everything.html>The All-In-One Almost-Alphabetical No-Bullshit Guide to Detecting Everything</a>
<li><a href=http://msdn.microsoft.com/en-us/ie/ff468705.aspx>Internet Explorer 9 Guide for Developers</a>
</ul>

<p class=a>&#x2767;

<p>Isso foi &#8220;Detectando funcionalidades da <abbr>HTML5</abbr>.&#8221; Consulte o <a href=table-of-contents.html>Sumário</a>, caso queira continuar com a leitura.

<div class="pf">
<h4>Você sabia?</h4>
<div class="moneybags">
<blockquote><p>Em associação a <span lang="en">Google Press</span>, O&#8217;Reilly está distribuindo este livro em variados formatos, incluindo papel, ePub, Mobi, <abbr>DRM</abbr>-free e <abbr>PDF</abbr>. A edição paga é chamada <span lang="en">“HTML5: Up &amp; Running”</span> e está disponível agora. Este capítulo está incluído na versão paga.
</p><p>Se você gostou deste capítulo e quer mostrar sua apreciação, basta <a href="http://www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027?ie=UTF8&amp;tag=diveintomark-20&amp;creativeASIN=0596806027">comprar o livro “<abbr>HTML5</abbr>: Up &amp; Running” com esse link afiliado</a> ou <a href="http://oreilly.com/catalog/9780596806033">comprar a edição eletrônica diretamente da O&#8217;Reilly</a>. Você vai ganhar um livro, e eu vou ganhar um trocado. Atualmente, não aceito doações diretas.
</p></blockquote>
</div>
</div>

<p class=c>Copyright MMIX&ndash;MMXI <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=017884302975346027366:bgclqh8nvse><input type=hidden name=ie value=UTF-8><input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<script src=j/jquery.js></script>
<script src=j/modernizr.js></script>
<script src=j/gears_init.js></script>
<script src=j/geo.js></script>
<script src=j/dih5.js></script>
<script src="http://maps.googleapis.com/maps/api/js?sensor=true"></script>
<script>
function supports(bool, suffix) {
  var s = "Your browser ";
  if (bool) {
    s += "supports " + suffix + ".";
  } else {
    s += "does not support " + suffix + ". :(";
  }
  return s;
}
function I_CAN_HAS(result) {
  if (result == "probably") {
    return "can play";
  }
  if (result == "maybe") {
    return "isn't sure if it can play";
  }
  return "can't play";
}
function lookup_location() {
  geo_position_js.getCurrentPosition(show_map, show_map_error);
}
function show_map(loc) {
  $("#geo-wrapper").css({'width':'320px','height':'350px'});
  var map = new google.maps.Map(document.getElementById("geo-wrapper"), {zoom: 14, mapTypeControl:true, zoomControl: true, mapTypeId: google.maps.MapTypeId.ROADMAP});
  var center = new google.maps.LatLng(loc.coords.latitude,loc.coords.longitude);
  map.setCenter(center);
  var marker = new google.maps.Marker({map: map, position: center, draggable: false, title: "You are here (more or less)"});
}
function show_map_error() {
  $("#live-geolocation").html('Unable to determine your location.');
}
$(function() {
  $("#live-canvas").html(supports(Modernizr.canvas, "the canvas API"));
  $("#live-canvas-text").html(supports(Modernizr.canvastext, "the canvas text API"));
  $("#live-video").html(supports(Modernizr.video, "HTML5 video"));
  if (Modernizr.video) {
    var ogg = Modernizr.video.ogg;
    var h264 = Modernizr.video.h264;
    var webm = Modernizr.video.webm;
    var vf = "Your browser ";
    if ((ogg == "probably") && (h264 == "probably")) {
      vf += "can play both Ogg Theora and H.264";
    } else if (((ogg == "") || (ogg == "no")) && (h264 == "probably")) {
      vf += "can play H.264 video, but not Ogg Theora";
    } else if (((h264 == "") || (h264 == "no")) && (ogg == "probably")) {
      vf += "can play Ogg Theora video, but not H.264";
    } else {
      vf += I_CAN_HAS(ogg) + " Ogg Theora video. Your browser " + I_CAN_HAS(h264) + " H.264";
    }
    vf += " video.";
    if (webm) {
      vf += " Hey, you can play WebM video, too!";
    }
    $("#live-video-formats").html(vf);
  } else {
    $("#live-video-formats").html(supports(Modernizr.video, "any video formats"));
  }
  var localstorage = false;
  try {
    localstorage = Modernizr.localstorage;
  } catch(e) {}
  $("#live-storage").html(supports(localstorage, "HTML5 storage"));
  $("#live-web-workers").html(supports(Modernizr.webworkers, "web workers"));
  $("#live-offline").html(supports(Modernizr.applicationcache, "offline web applications"));
  if (geo_position_js.init()) {
    $("#live-geolocation").html(supports(true, "geolocation") + ' <a href="#" onclick="lookup_location();return false">Click to look up your location</a>.');
  } else {
    $("#live-geolocation").html(supports(false, "geolocation"));
  }
  var supported_input_types = '';
  for (var itype in Modernizr.inputtypes) {
    if (Modernizr.inputtypes[itype]) {
      supported_input_types += '<code>' + itype + '</code>, ';
    }
  }
  if (!!supported_input_types) {
    $("#live-input-types").html('Your browser supports the following HTML5 input types: ' + supported_input_types.replace(/, $/, ''));
  } else {
    $("#live-input-types").html('Your browser does not support any HTML5 input types.');
  }
  $("#live-input-autofocus").html(supports(!!("autofocus" in document.createElement("input")), "form autofocus"));
  $("#live-microdata-api").html(supports(!!document.getItems, "the HTML5 microdata API"));
  $("#live-history-api").html(supports(!!Modernizr.history, "the HTML5 history API"));
});
</script>
