<!DOCTYPE html>
<meta charset=utf-8>
<title>Video - Dive Into HTML5</title>
<!--[if lt IE 9]><script src=j/html5.js></script><![endif]-->
<link rel=alternate type=application/atom+xml href=https://github.com/diveintomark/diveintohtml5/commits/master.atom>
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=prefetch href=index.html>
<p>Você está aqui: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#video>Dive Into <abbr>HTML5</abbr></a> <span class=u>&#8227;</span>
<h1><br>Vídeo na Web</h1>
<p id=toc>&nbsp;
<p class=a>&#x2767;
<h2 id=divingin>Mergulhando</h2>

<p class=f><img src=i/aoc-q.png alt=Q width=105 height=105>ualquer um que tenha visitado o Youtube.com nos últimos quatro anos sabe que você pode incorporar um vídeo em uma página web. Mas antes do <abbr>HTML5</abbr>, não havia nenhuma maneira beaseada nos padrões para fazer isso. Virtualmente todos os vídeos já assistidos &#8220na web&#8221; eram afunilados por um plugin de terceiros &mdash; talvez QuickTime, talvez RealPlayer, talvez Flash. (YouTube usa Flash.) Esses plugins se integram com seu browser o suficiente que você nem é avisado quando está utilizando eles. Isso é, até o momento em que você tentar assistir um vídeo em uma plataforma que não suporta esse plugin.

<p><abbr>HTML5</abbr> define uma maneira padrão de incorporar vídeo em uma página web, usando o elemento <code>&lt;video></code>. O suporte para o elemento <code>&lt;video></code> ainda está evoluindo, o que é um modo educado de dizer que ainda não está funcionando. Pelo menos, ele não funciona em todos os lugares. Mas não se desespere! Existem alternativas, fallbacks e uma abundância de opções.

<table class=bc>
<caption>Suporte ao elemento &lt;video></caption>
<thead>
<tr><th title="Internet Explorer">IE<th title="Mozilla Firefox">Firefox<th title="Apple Safari">Safari<th title="Google Chrome">Chrome<th>Opera<th>iPhone<th>Android
<tbody>
<tr><td>9.0+<td>3.5+<td>3.0+<td>3.0+<td>10.5+<td>1.0+<td>2.0+
</table>

<p>Mas o suporte para o elemento <code>&lt;video></code> em si é realmente uma pequena parte da história. Antes de falarmos sobre o vídeo da <abbr>HTML5</abbr>, você precisa entender primeiro um pouco sobre vídeo em si. (Se você já sabe sobre vídeo, você pode pular para <a href=#what-works>O Que Funciona na Web</a>.)

<p class=a>&#x2767;

<h2 id=video-containers>Embalagens de Vídeo</h2>

<p>Você pode pensar em arquivos de vídeo como &#8220;arquivos AVI&#8221; ou &#8220;arquivos MP4.&#8221; Na realidade, &#8220;AVI&#8221; e &#8220;MP4&#8243; são apenas os formatos das embalagens de vídeo. Assim como um arquivo ZIP pode conter qualquer tipo de arquivo dentro dele, os formatos das embalagens de vídeo definem apenas <em>como</em> armazenar as coisas dentro dele, e não <em>quais</em> tipos de dados são armazenados. (É um pouco mais complicado que isso, porque nem todos os fluxos de vídeo são compatíveis com todos os formatos de embalagens, mas esqueça isso por enquanto.)

<p>Um arquivo de vídeo usualmente contém múltiplas <em>faixas</em> &#8212; uma faixa de vídeo (sem áudio), além de uma ou mais faixas de áudio (sem vídeo). As faixas usualmente se interlaçam. Uma faixa de áudio contém marcações dentro dela para ajudar na sincronização entre áudio e vídeo. Faixas individuais podem ter metadados, como relações de aspectos de uma faixa de vídeo, ou a linguagem de uma faixa de áudio. Essas embalagens também podem ter metadados, como o título do próprio vídeo, uma capa para o vídeo, números de episódios (para programas de televisão), e por aí vai.
 
<p>Existem <em>vários</em> formatos para embalagens de vídeo. Os mais populares incluem
 
<ul> 
<li><a href=http://en.wikipedia.org/wiki/MPEG-4_Part_14>MPEG 4</a>, usualmente com a extensão <code>.mp4</code> ou <code>.m4v</code>. A embalagem MPEG 4 é <a href=http://www.chiariglione.org/mpeg/technologies/mp04-ff/index.htm>baseada na antiga embalagem QuickTime da Apple</a> (<code>.mov</code>). <a href=http://www.apple.com/trailers/>Trailers de filmes no site da Apple</a> ainda utilizam a antiga embalagem QuickTime, mas filmes que você aluga no iTunes são entregues na embalagem MPEG 4.</li> 
<li><a href=http://en.wikipedia.org/wiki/Flash_Video>Flash</a>, usualmente com a extensão <code>.flv</code>. Vídeos em Flash são, sem surpresa, usados pelo Adobe Flash. Antes do Flash 9.0.60.184 (a.k.a. Flash Player 9 Update 3), esse era o único formato de embalagem que o Flash suportava. Versões mais recentes do Flash também suportam a embalagem MPEG 4.</li> 
<li><a href=http://en.wikipedia.org/wiki/Ogg>Ogg</a>, usualmente com a extensão <code>.ogv</code>. Ogg é um padrão aberto, de código livre, e descoberto de quaisquer patentes conhecidas. Firefox 3.5, Chrome 4, e Opera 10.5 suportam &#8212; nativamente, sem qualquer plataforma específica de plugins &#8212; o formato de embalagem Ogg, Ogg vídeo (chamado &#8220;Theora&#8221;), e Ogg áudio (chamado &#8220;Vorbis&#8221;). No desktop, Ogg é suportado fora-da-caixa por todas as principais distribuições Linux, e você pode usá-lo no Mac e Windows ao instalar os <a href=http://www.xiph.org/quicktime/>componentes QuickTime</a> ou <a href=http://www.xiph.org/dshow/>filtros DirectShow</a>, respectivamente. É ainda executado pelo excelente <a href=http://www.videolan.org/vlc/>VLC</a> em todas as plataformas.</li> 
<li><a href=http://www.webmproject.org/>WebM</a> é um novo formato de embalagem. É tecnicamente similar a outro formato, chamado <a href=http://en.wikipedia.org/wiki/Matroska>Matroska</a>. WebM foi anunciado em Maio de 2010. Foi projetado para ser usado exclusivamente com o codec de vídeo VP8 e pelo codec de áudio Vorbis. (Mais obre isso em um minuto.) É formato nativamente, sem qualquer plataforma específica de plugins, nas últimas versões do Chromium, Google Chrome, Mozilla Firefox, e Opera. Adobe também anunciou que uma futura versão do Flash irá suportar vídeos em WebM.</li>
<li><a href=http://en.wikipedia.org/wiki/AVI>Audio Video Interleave</a>, usualmente com a extensão <code>.avi</code>. O formato de embalagem AVI foi inventado pela Microsoft em um tempo mais simples, quando o fato de que computadores podiam tocar vídeos já era considerado incrível. Oficialmente não suporta funcionalidades dos mais recentes formatos de embalagens como metadados incorporados. Oficialmente não suporta até mesmo os mais modernos codecs de áudio e vídeo utilizados hoje em dia. Com o tempo, companhias tentaram extendê-lo de forma incompatível para suportar isso ou aquilo, e ainda é o formato de embalagem padrão para encoders como <a href=http://www.mplayerhq.hu/DOCS/HTML/en/encoding-guide.html>MEncoder</a>.</li> 
</ul> 

<p class=a>&#x2767;

<h2 id=video-codecs>Codecs de Vídeo</h2>

<p>Quando você fala sobre &#8220;assistir um vídeo,&#8221; você está provavelmente falando da combinação de um fluxo de vídeo e um fluxo de áudio. Mas você não tem dois arquivos diferentes; você tem apenas &#8220;um vídeo.&#8221 Talvez possa ser um arquivo AVI, ou um arquivo MP4. Esses são <a href=#video-containers>apenas formatos de embalagem</a>, como um arquivo ZIP que contém múltiplos tipos de arquivos dentro dele. O formato de embalagem define como serão armazenados os fluxos de vídeo e áudio em um único arquivo.
 
<p>Quando você &#8220;assiste um vídeo,&#8221; seu video player está fazendo pelo menos três coisas ao mesmo tempo: 
 
<ol> 
<li>Interpretando o formato de embalagem para descobrir quais faixas de vídeo e áudio estão disponíveis, e como elas são armazenadas dentro do arquivo para que possa encontrar os dados que necessitam ser decodificados depois</li> 
<li>Decodificando o fluxo de vídeo e exibindo uma série de imagens na tela</li> 
<li>Decodificando o fluxo de áudio e enviando o som para as caixas de som</li> 
</ol> 
 
<p>Um <i>codec de vídeo</i> é um algoritmo que será encodificado em um fluxo de vídeo, i.e. ele especifica como fazer a seguir. (A palavra &#8220;codec&#8221; é um <a href=http://en.wikipedia.org/wiki/Portmanteau>portmanteau</a>, a combinação das palavras &#8220;codificar&#8221; e &#8220;decodificar.&#8221;) Seu video player <i>decodifica</i> o fluxo de vídeo de acordo com o <i>codec de vídeo</i>, depois exibe uma série de imagens, ou &#8220;frames,&#8221; na tela. A maioria dos codecs de vídeo modernos usam diversas formas para minimizar a quantidade de informação necessária para exibir um frame atrás do outro. Por exeplo, ao invés de armazenar cada frame individualmente (como um screenshot), eles irão armazenar apenas as diferenças entre os frames. A maioria dos vídeos na realidade não mudam completamente entre um frame e o outro, então isso permite alto grau de compressão, resultando em menores tamanhos de arquivo.
 
<p>Existem codecs de vídeo <i>com perdas</i> e <i>sem perdas</i>. Vídeos sem perdas são muito grandes para serem usados na web, então irei me concentrar em codecs com perdas. Um <i>codec com perdas</i> significa que informação será irremediavelmente perdida durante o processo de encodificação. Como a cópia do áudio de uma fita cassete, você está perdendo informação sobre a fonte do vídeo, e degradando a qualidade, cada vez que você codifica. Ao invés do &#8220;assobio&#8221; de uma fita cassete de áudio, uma re-re-re-encodificação de vídeo pode parecer bloqueada, especialmente durante cenas com muita ação. (Na verdade, isso pode acontecer até se você codificar direto da fonte original, se você escolher um codec de vídeo pobre ou passar para ele o conjunto errado de parâmetros.) O lado bom é que codecs de vídeo com perdas podem oferecer taxas de compressão incríveis através da suavização sem bloqueios durante a reprodução, para fazer a perda menos perceptível ao olho humano.
 
<p>Existe uma <a href=http://samples.mplayerhq.hu/V-codecs/><em>porção</em> de codecs de vídeo</a>. Os três codecs mais relevantes são <a href=#h264>H.264</a>, <a href=#theora>Theora</a>, e <a href=#vp8>VP8</a>.
 
<h3 id=h264>H.264</h3>
 
<p><a href=http://en.wikipedia.org/wiki/H.264>H.264</a> mais conhecido como &#8220;MPEG-4 part 10,&#8221; a.k.a. &#8220;MPEG-4 AVC,&#8221; a.k.a. &#8220;MPEG-4 Advanced Video Coding.&#8221;  H.264 foi desenvolvido pelo <a href=http://en.wikipedia.org/wiki/Moving_Picture_Experts_Group>MPEG group</a> e padronizado em 2003. Tem por objetivo oferecer um único codec para banda-larga pobre, CPU de dispositivos pobres (celulares); alta banda-larga, alta CPU de dispositivos (computadores modernos); e qualquer coisa no meio disso. Para realizar isso, o padrão H.264 é dividido em &#8220;<a href=http://en.wikipedia.org/wiki/H.264#Profiles>perfis</a>,&#8221; onde cada um define um conjunto de funcionalidades opcionais que negocia a complexidade pelo tamanho do arquivo. Altos perfis usam mais funcionalidades opcionais, oferecem melhor qualidade visual para tamanhos de arquivo menores, levam mais tempo para codificar, e requerem mais poder da CPU para codificar em tempo real.

<p>Para lhe dar uma ideia da variedade dos perfis, o <a href=http://www.apple.com/iphone/specs.html>iPhone da Apple suporta o perfil Baseline</a>, a <a href=http://www.apple.com/appletv/specs.html>AppleTV suporta os perfis Baseline e Main</a>, e <a href=http://www.kaourantin.net/2007/08/what-just-happened-to-video-on-web_20.html>Adobe Flash em um PC suporta os perfis Baseline, Main, e High</a>. YouTube usa agora o H.264 para codificar <a href=http://blog.wired.com/business/2008/12/youtube-adds-hd.html>vídeos de alta definição</a>, tocados a partir do Adobe Flash; YouTube também provê vídeo codificado com H.264 para dispositivos móveis, incluindo iPhone e telefones rodando o <a href=http://code.google.com/android/>sistema operacional móvel Android</a>. Além do H.264 ser um dos codecs de vídeo mandatários pela especificação do Blu-Ray; discos Blu-Ray que usam ele geralmente utilizam no perfil High. 

<p>A maioria dos dispositivos, que não são PCs, tocam vídeo em H.264 (incluindo iPhones e reprodutores de Blu-Ray) 
Most non-PC devices that play H.264 video (including iPhones and standalone Blu-Ray players) na verdade realizam a decodificação em um chip dedicado, uma vez que suas CPUs principais estão longe de ter poder o suficiente para decodificar em tempo real. Atualmente, até mesmo placas gráficas de baixo nível suportam decodificação H.264 no hardware. Existem <a href=http://compression.ru/video/codec_comparison/mpeg-4_avc_h264_2007_en.html>codificadores H.264 concorrentes</a>, incluindo o open source <a href=http://www.videolan.org/developers/x264.html>x264</a>. <b>O padrão H.264 está coberto por patentes</b>; licenciamento é intermediado pelo <a href=http://www.mpegla.com/>MPEG LA group</a>. Vídeo H.264 pode ser incorporado nos mais populares <a href=#video-containers>formatos de contêiner</a>, incluindo MP4 (usado primeiramente pela <a href=http://www.apple.com/itunes/whatson/movies.html> iTunes Store da Apple</a>) e MKV (usado primeiramente por entusiastas de vídeo não-comerciais).
 
<h3 id=theora>Theora</h3>
 
<p><a href=http://en.wikipedia.org/wiki/Theora>Theora</a> evoluiu do <a href=http://en.wikipedia.org/wiki/Theora#History>VP3 codec</a> e tem sido subseqüentemente desenvolvido pela <a href=http://xiph.org/>Xiph.org Foundation</a>. <b>Theora é um codec livre de royalties e não é onerado por qualquer patente conhecida</b> a não ser a patente original VP3, que foi licenciada livre de royalties. Embora o padrão tenha sido &#8220;congelado&#8221; desde 2004, o projeto Theora (que inclui um referente codificador e decodificador open source) <a href=http://lists.xiph.org/pipermail/theora-dev/2008-November/003736.html>apenas lançou a versão 1.0 em novembro de 2008</a> e a <a href=http://lists.xiph.org/pipermail/theora-dev/2009-September/003985.html>versão 1.1 em setembro de 2009</a>. 
<p>Vídeos em Theora podem ser incorporados em qualquer formato contêiner, embora seja mais visto em Ogg. A maioria das distribuições Linux suportam Theora fora-da-caixa, e o Mozilla Firefox 3.5 <a href=https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox>inclui suporte nativo a vídeos Theora</a> no contêiner Ogg. E por &#8220;nativo&#8221;, eu digo &#8220;disponível em qualquer plataforma sem plugins específicos daquela plataforma.&#8221;  Você pode também reproduzir vídeos Theora <a href=http://www.xiph.org/dshow/>no Windows</a> ou <a href=http://xiph.org/quicktime/>no Mac OS X</a> após instalar o software open source decodificador Xiph.org&#8217;. 

<h3 id=vp8>VP8</h3>

<p><a href=http://en.wikipedia.org/wiki/VP8>VP8</a> é outro codec de vídeo da On2, mesma compania que originalmente desenvolveu o VP3 (mais tarde Theora). Técnicamente, ele produz saída em par com o perfil H.264 High, enquanto mantém uma baixa complexidade de decodificação em par com o perfil H.264 Baseline.

<p>Em 2010, a Google adquiriu a On2 e publicou a especificação do codec de vídeo e uma amostra open source do codificador e decodificador. Como parte disso, a Google também &#8220;abriu&#8221; todas as patentes que a On2 mantinha sobre o VP8, ao licenciar livre de royalties. (Esse é o melhor que você pode esperar para patentes. Na verdade você não pode &#8220;lançar&#8221; ou anular elas uma vez emitidas. Para torná-las open source, você as licencia livre de royalties, e então qualquer um pode usar a tecnologia que a patente cobre sem pagar qualquer coisa ou negociar as licenças.) A partir de 19 de maio de 2010, <b>VP8 se tornou livre de royalties, um codec moderno e não onerado por qualquer patente conhecida</b>, diferente das patentes que a On2 (agora Google) já licenciou livre de royalties.

<p class=a>&#x2767;

<h2 id=audio-codecs>Codecs de Áudio</h2>

<p>A não ser que você ainda esteja parado nos filmes feitos antes de <a href=http://www.filmsite.org/jazz.html>1927</a>, você irá querer uma trilha de som no seu vídeo. Como <a href=#video-codecs>codecs de vídeo</a>, <i>codecs de áudio</i> são algoritmos nos quais fluxos de áudio são codificados. Como codecs de vídeo, os codecs de áudio são <i>com perda</i> e <i>sem perda</i>. E como os codecs de vídeo sem perda, áudios sem perda são realmente muito grandes para colocar na web. Então irei me concentrar em codecs de áudio com perda.

<p>Na verdade, é ainda mais estreito que isso, porque eles estão em diferentes categorias de codecs de áudio com perda. Áudio é usado em lugares onde o vídeo não é (telefonia, por exemplo) e existe toda uma categoria de <a href=http://www.voip-info.org/wiki-Codecs>codecs de áudio otimizados para codificar voz</a>. Você não iria utilizar um desses codecs para um CD de música, porque o resultado seria como uma criança de 4 anos de idade cantando em um viva-voz. Mas você <em>iria</em> usar eles em um <a href=http://www.asterisk.org/>Asterisk</a> PBX, porque a banda é preciosa, e esses codecs podem comprimir a voz humana em uma fração do tamanho que codecs gerais. Entretanto, graças a falta de suporte em ambos navegadores nativos ou plugins terceiros, codecs de áudio otimizados para voz nunca chegaram realmente na web. Então irei concentrar em <i>codecs de áudio com propósito geral</i>.
 
<p><a href=#video-codecs>Eu mencionei mais cedo</a>, quando você &#8220;assiste um vídeo,&#8221; seu computador está fazendo ao menos três coisas ao mesmo tempo: 
 
<ol> 
<li>Interpretando o contêiner do formato</li> 
<li>Decodificando o fluxo de vídeo</li> 
<li>Decodificando o fluxo de áudio e enviando o som para os alto-faltantes</li> 
</ol> 
 
<p>O <i>codec de áudio</i> especifica como #3 &#8212; decodificar o fluxo de áudio e torná-lo em ondas digitais que depois seus alto-falantes transformam em som. Assim como os codecs de vídeo, existem todos os tipos de truques para minimizar a quantidade de informação armazenada em um fluxo de áudio. E já que estamos falando sobre codecs de áudio <i>com perda</i>, a informação está sendo perdida durante a gravação <span class=u>&rarr;</span> codificação <span class=u>&rarr;</span> decodificação <span class=u>&rarr;</span> ciclo de vida da escuta. Diferentes codecs de áudio jogam fora diferentes coisas, mas eles tem o mesmo objetivo: enganar seus ouvidos para não notar as partes que estão faltando. 
 
<p>Um conceito que o áudio tem que o vídeo não tem são os <i>canais</i>. Nós estamos enviando som para os alto-falantes, certo? Bom, quantos alto-falantes você tem? Se você está sentado em um computador, você deve ter apenas dois: um na esquerda e um na direita. Meu desktop tem três: esquerda, direita e mais um no chão. Chamado &#8220;<a href=http://en.wikipedia.org/wiki/Surround_sound>surround sound</a>&#8221; sistemas podem ter seis ou mais alto-falantes, estratégicamente colocados pelo lugar. Cada alto-falante alimenta um <i>canal</i> em particular da gravação original. A teoria é que você pode sentar no meio dos seis alto-falantes, literalmente cercado por seis diferentes canais do som, e seu cérebro sintetiza eles e parece que você está no meio da ação. Isso funciona? Uma indústria multi-bilionária parece acreditar que sim.
 
<p>Codecs de áudio com propósito geral podem lidar com dois canais de som. Durante a gravação, o som é dividido no canal da esquerda e da direita; durante a codificação, ambos canais armazenam o mesmo fluxo de áudio; durante a decodificação, ambos canais estão decodificados e cada um é enviado para o alto-falante apropriado. Alguns codecs de áudio podem lidar com mais de dois canais, e irão controlar qual canal é qual e então seu reprodutor de áudio pode enviar para o som da direita para o alto-falante da direita.
 
<p>Existem <em>muitos</em> codecs de áudio. Eu disse que haviam muitos codecs de vídeo? Esqueça isso. Existem <a href="http://wiki.multimedia.cx/index.php?title=Category:Audio_Codecs">dezenas e dezenas de codecs de áudio</a>, mas na web, existem apenas que você deveria conhecer mais sobre: <abbr>MP3</abbr>, <abbr>AAC</abbr>, e Vorbis.
 
<h3 id=mp3>MPEG-1 Audio Layer 3</h3>
 
<p><a href=http://en.wikipedia.org/wiki/MPEG-1_Audio_Layer_3>MPEG-1 Audio Layer 3</a> é coloquialmente conhecido como &#8220;MP3.&#8221; Se você nunca ouviu falar de MP3s, eu não sei o que fazer com você. <a href="http://www.walmart.com/catalog/catalog.gsp?cat=96469">Walmart vende reprodutores de música portáveis</a> e os chama de &#8220;MP3 players.&#8221; <em>Walmart.</em> Em todo caso&#8230; 
 
<p>MP3s podem conter <strong>até dois canais</strong> de som. Eles podem ser codificados em diferentes <i>taxas de bits</i>: 64 kbps, 128 kbps, 192 kbps, e uma varidade de outros de 32 à 320. Altas taxas de bits significam tamanhos de arquivos maiores e melhor qualidade no áudio, embora a relação da taxa da qualidade com a taxa de bits não seja linear. (128 kbps soa duas vezes melhor que 64 kbps, mas 256 kbps não soa o dobro melhor que 128 kbps.) Além disso, o formato MP3 permite <i>codificação variável na taxa de bits</i>, o que significa que algumas partes do fluxo de codificação são mais comprimidas que outras. Por exemplo, silêncio entre as notas podem ser codificadas em uma baixa taxa de bits, então a taxa de bits pode aumentar um momento mais tarde quando múltiplos instrumentos começam a tocar um acorde complexo. MP3s também podem ser codificados em uma taxa de bits constante, que, sem surpresas, é chamado de <i>codificação a taxas de bits constantes</i>. 
 
<p>O padrão MP3 não define exatamente como codificar MP3s (embora defina exatamente como devemos decodificá-los); diferentes codificadores usam diferentes modelos psicoacústicos que produzem resultados descontroladamente diferentes, mas são todos decodificados pelos mesmos players. O projeto open source <a href=http://lame.sourceforge.net/>LAME</a> é o melhor codificador gratuito, e sem dúvida o melhor codificador, ponto final, para todos menos para baixas taxas de bits. 
 
<p>O formato MP3 (padronizado em 1991) <strong>é coberto de patentes</strong>, que explicam porque Linux não pode&#821 tocar arquivos MP3 fora da caixa. Praticamente todos os players de música portáveis suportam arquivos MP3s, e os fluxos de áudio MP3 podem ser embutidos em qualquer <a href=http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats>container de vídeo</a>. Adobe Flash pode ambos, arquivos MP3 e fluxo de áudio MP3 com um container de vídeo MP4. 
 
<h3 id=aac>Codificação de Áudio Avançada</h3>
 
<p><a href=http://en.wikipedia.org/wiki/Advanced_Audio_Coding>Codificação de Áudio Avançada</a> é efetivamente conhecida como "AAC" (Advanced Audio Coding). Padronizada em 1997, deu uma "levantada" proeminente quando a Apple escolheu o MP3 como formato padrão para a iTunes Store. Originalmente, todos os arquivos "AAC" &#8220comprados&#8221; pela loja do iTunes eram criptografados com um esquema DRM proprietário da Apple, chamado <a href=http://en.wikipedia.org/wiki/FairPlay>FairPlay</a>. Músicas selecionadas na loja iTunes agora estão disponíveis como arquivos desprotegidos AAC, que a Apple chama de &#8220;iTunes Plus&#8221; pois soa muito melhor do que chamar todo o resto de &#8220;iTunes Minus.&#8221;  <strong>O formato AAC é coberto de patentes</strong>; <a href=http://www.vialicensing.com/Licensing/AAC_fees.cfm> taxas de licença são disponibilizadas online</a>. 
 
<p>AAC foi desenvolvido para promover uma qualidade de som melhor que MP3 na mesma <i>taxa de bits</i>, e pode codificar áudio em qualquer taxa de bits. (MP3 é limitado a um número fixo de taxa de bits, com um limite superior de  320 kbps.)  AAC pode codificar <strong>até 48 canais de som</strong>, embora na prática ninguém faça isso. O formato AAC também difere do MP3 na definição de múltiplos <i>perfis</i>, na maioria das vezes como <a href=http://diveintomark.org/archives/2008/12/19/give-part-2-lossy-video-codecs#h264>H.264</a>, e pelas mesmas razões. O perfil de &#8220;baixa complexidade&#8221 é desenvolvido para ser reproduzido em tempo real em dispositivos com poder de CPU limitado, enquanto perfis altos oferecem melhor qualidade na mesma taxa de bits ao preço de lentidão na codificação ou decodificação. 
 
<p>Todos os atuais produtos da Apple, incluindo iPods, AppleTV, e QuickTime suportam alguns perfis de AAC tanto em arquivos de áudio e em fluxos de áudio dentro um container de vídeo MP4. Adobe Flash suporta todos os perfis de AAC em MP4, como fazem os reprodutores de vídeo MPlayer e VLC. Para codificação, a biblioteca FAAC é a opção open source; o suporte é uma opção em tempo de compilação em mencoder e ffmpeg.
 
<h3 id=vorbis>Vorbis</h3>
 
<p><a href=http://en.wikipedia.org/wiki/Vorbis>Vorbis</a> também chamado de &#8220;Ogg Vorbis,&#8221; embora esteja técnicamente incorreto. (&#8220;Ogg&#8221; e apenas um<a href=#video-containers>formato de container </a>, e fluxos de áudio Vorbis podem ser embutido em outros containers.) <strong>Vorbis não é coberto por nenhuma patente conhecida</strong> e portanto é suportado fora da caixa pela maioria das distribuições Linux e dispositivos portáteis rodando o open source <a href=http://www.rockbox.org/>Rockbox</a> firmware. Mozilla Firefox 3.5 suporta arquivos de áudio Vorbis em um container Ogg, ou Ogg vídeos com uma faixa de áudio Vorbis. <a href=http://code.google.com/android/>Android</a> celulares também podem reproduzir arquivos de audio Vorbis. streams de  audio Vorbis geralmente sao embutidas em um Ogg ou em WebM contêiner, mas ele também podem ser<a href=http://samples.mplayerhq.hu/MPEG-4/vorbis-in-mp4/>embutidos em um MP4</a> ou <a href=http://en.wikipedia.org/wiki/Matroska>MKV</a> container (ou, com algum hacking, <a href=http://www.alexander-noe.com/video/amg/>em AVI</a>). Vorbis suporta <strong>um numero arbitrário de canais de som</strong>.
 
<p>Existem codificadores e decodificadores Vorbis open source, incluindo <a href=http://oggconvert.tristanb.net/>OggConvert</a> (codificador), <a href=http://www.ffmpeg.org/>ffmpeg</a> (decodificador), <a href=http://www.geocities.jp/aoyoume/aotuv/>aoTuV</a> (codificador), e <a href=http://downloads.xiph.org/releases/vorbis/>libvorbis</a> (decodificador). Também existem <a href=http://www.xiph.org/quicktime/>Componentes QuickTime para Mac OS X</a> e <a href=http://www.xiph.org/dshow/>Filtros DirectShow para Windows</a>. 

<p class=a>&#x2767;

<h2 id=what-works>O que funciona na Web</h2>

<p>Se os seus olhos não estão vidrados ainda, você está melhor que a maioria. Como você pode dizer, vídeo (e áudio) é um assunto complicado e esta foi a versão abreviada! Eu tenho certeza que você está se perguntando como tudo isso se relaciona com <abbr>HTML5</abbr>. Bem, <abbr>HTML5</abbr> inclue um elemento <code>&lt;video></code> para embutir vídeos em uma página web. Não há restrição no codec do vídeo, codec do áudio. ou no formato de container que você pode usar para seu vídeo. Um elemento <code>&lt;video></code> pode ter um link para múltiplos arquivos de vídeos, e o navegador escolhe qual o primeiro vídeo que irá reproduzir. <strong>Cabe a você saber qual navegador suporta qual containers e codecs.</strong>

<p>Como está escrito, está é a paisagem do vídeo <abbr>HTML5</abbr>:

<ul>
<li>Mozilla Firefox (3.5 e superior) suporta vídeo Theora e áudio Vorbis em container Ogg. Firefox 4 também suporta WebM.
<li>Opera (10.5 e superior) suporta vídeo Theora e áudio Vorbis em um container Ogg. Opera 10.60 também suporta WebM.
<li>Google Chrome (3.0 e superior) suporta vídeo Theora e áudio Vorbis em um container Ogg. Google Chrome 6.0 também suporta WebM.
<li>Safari no Macs e PCs Windows (3.0 e superior) irão suportar tudo que o QuickTime suporta. Em teoria, você não pode requerer que seus usuários instalem plugins QuickTime de terceiros. Na prática, alguns usuários estão fazendo isto. Então você é deixado com os formatos que o QuickTime suporta "fora da caixa." Esta é uma lista longa, mas não inclue WebM, Theora, Vorbis, ou o container Ogg. Contudo, QuickTime <em>fornece</em> suporte para vídeo H.264 (perfil principal) e áudio AAC em um container MP4.
<li>Celulares como iPhone da Apple e celulares com Android da Google suportam vídeo H.264 (perfil de base) e áudio AAC  (perfis de "baixa complexidade") em um container de MP4.
<li>Adobe Flash (9.0.60.184 e superior) suporta vídeos H.264 (todos os perfis) e áudio AAC (todos os perfis) em um container MP4.
<li>Internet Explorer 9 suporta todos os perfis de vídeos H.264 ou AAC ou áudio MP3 em um container MP4. Também irá reproduzir vídeo WebM se você instalar algum codec de terceiro, que por padrão não é instalado por nenhuma versão do Windows. IE9 não suporta outros codecs de terceiros (ao contrário do Safari, que vai reproduzir tudo que o QuickTime pode reproduzir).
<li>Internet Explorer 8 não tem suporte de vídeo <abbr>HTML5</abbr> em geral, mas praticamente todos os usuários de Internet Explorer terão o plugin Adobe Flash. Mais adiante neste capítulo, Eu vou mostrar para você como usar vídeo <abbr>HTML5</abbr> e gerar um fallback em Flash.
</ul>

<p>Isto deve ser mais fácil de digerir em forma de tabela.

<table class=bc>
<caption>Suporte de codecs de vídeo nos navegadores atualmente</caption>
<thead>
<tr><th style="text-align:left">Codecs/container<th title="Internet Explorer">IE<th title="Mozilla Firefox">Firefox<th title="Apple Safari">Safari<th title="Google Chrome">Chrome<th>Opera<th>iPhone<th>Android
<tbody>
<tr><th>Theora+Vorbis+Ogg<td>&middot;<td>3.5+<td>&dagger;<td>5.0+<td>10.5+<td>&middot;<td>&middot;
<tr><th>H.264+AAC+MP4<td>&middot;<td>&middot;<td>3.0+<td>5.0&ndash;?&Dagger;<td>&middot;<td>3.0+<td>2.0+
<tr><th>WebM<td>&middot;<td>&middot;<td>&dagger;<td>6.0+<td>10.6+<td>&middot;<td>&middot;
<tfoot>
<tr><td colspan=8 style="text-align:left">&dagger; Safari irá reproduzir tudo que o QuickTime reproduz. QuickTime vem pre-instalado com suporte H.264/AAC/MP4. Existem plugins de terceiros instalaveis que provém suporte para Theora e WebM, mas cada usuário precisa instalar esses plugins antes do Safari reconhecer os formatos dos vídeos.
<tr><td colspan=8 style="text-align:left">&Dagger; Google Chrome irá <a href=http://blog.chromium.org/2011/01/html-video-codec-support-in-chrome.html>perder o suporte a H.264</a> em breve. <a href=http://blog.chromium.org/2011/01/more-about-chrome-html-video-codec.html>Ler sobre o por que</a>.
</table>

<p>Daqui há um ano, a paisagem vai parecer significativamente diferente com WebM implementado em múltiplos navegadores, estes navegadores habilitarão versões não-experimentais do WebM, e atualizações dos usuários para as novas versões.

<table class=bc>
<caption>Suporte de codecs de vídeo nos navegadores futuramente</caption>
<thead>
<tr><th style="text-align:left">Codecs/container<th title="Internet Explorer">IE<th title="Mozilla Firefox">Firefox<th title="Apple Safari">Safari<th title="Google Chrome">Chrome<th>Opera<th>iPhone<th>Android
<tbody>
<tr><th>Theora+Vorbis+Ogg<td>&middot;<td>3.5+<td>&dagger;<td>5.0+<td>10.5+<td>&middot;<td>&middot;
<tr><th>H.264+AAC+MP4<td>9.0+<td>&middot;<td>3.0+<td>&middot;<td>&middot;<td>3.0+<td>2.0+
<tr><th>WebM<td>&nbsp;9.0+<sup>*</sup><td>4.0+<td>&dagger;<td>6.0+<td>10.6+<td>&middot;<td>2.3&Dagger;<sup>
<tfoot>
<tr><td colspan=8 style="text-align:left">* Internet Explorer 9 vai suportar apenas WebM &#8220;<a href="http://windowsteamblog.com/windows/b/bloggingwindows/archive/2010/05/19/another-follow-up-on-html5-video-in-ie9.aspx">quando o usuario tiver instalado um codec VP8</a>, "o que implica que a Microsoft não enviará o codec deles mesmos.
<tr><td colspan=8 style="text-align:left">* Safari irá reproduzir tudo que o QuickTime pode reproduzir, mas QuickTime  vem apenas com suporte H.264/AAC/MP4 pré-instalado.
<tr><td colspan=8 style="text-align:left">* Embora o Android 2.3 suporte WebM, ainda não existem decodificadores de hardwares, dessa forma a vida da bateria é uma preocupação.
</table>

<p>E agora para o soco de nocaute:

<div class=pf>
<h4>Professor Markup Diz</h4>
<div class=inner>
<blockquote><p>Não existem únicas combinações de contêiners e codecs que funcionem em todos os navegadores <abbr>HTML5</abbr>.
<p>E isso não vai mudar em um futuro tão próximo.
<p>Para fazer seu vídeo assistível em todos esses dispositivos e plataformas, você precisará codificar seu vídeo mais de uma vez.
</blockquote>
</div>
</div>

<p>Para máxima compatibilidade, aqui está o fluxo de trabalho com o que seu vídeo deve parecer.

<ol>
<li>Fazer uma versão que usa WebM (VP8 + Vorbis).
<li>Fazer outra versão que use linhas de bases de vídeo H.264 e audio AAC "baixa complexidade" em um contêiner MP4.
<li>Fazer outra versão que use vídeo Theora e audio Vorbis em um contêiner Ogg.
<li>Linkar todos os três arquivos de vídeo apartir de um único elemento <code>&lt;video></code>, e um "fallback" para um reprodutor de vídeo flash.
</ol>

<p class=a>&#x2767;

<h2 id=licensing>Problemas de Licenciamento com vídeo H.264</h2>

<p>Antes de nós continuarmos, eu preciso salientar que há um custo em codificar seu vídeo duas vezes. Bem, existe um custo óbvio, que você tem que codificar seu vídeo duas vezes, o que consome mais computador e mais tempo do que se fosse feito apenas uma vez. Mas há outro custo real associado com vídeo H.264: custos de licenciamento.

<p>Se lembram quando eu expliquei <a href=#h264>vídeo H.264</a>, e eu mencionei que o codec de vídeo tem patentes-embutidas e o licenciamento foi quebrado pelo consórcio MPEG LA. Isso acaba sendo importante. Para entender porque isso é importante, eu te direciono para <a href="http://www.streamingmedia.com/Articles/Editorial/Featured-Articles/The-H.264-Licensing-Labyrinth-65403.aspx">O labirinto do licenciamento H.264</a>:

<blockquote>
<p>MPEG LA Divide a licença de portifólio H.264 em duas sub-licenças: uma para manufaturas de codificadores e decodificadores e a outra para distribuidores de conteúdo. &hellip;

<p>A sub-licença do lado dos distribuidores fica ainda mais dividida em quatro sub-categorias chaves, duas delas (assinaturas e aquisição título-por-título ou uso remunerado) são ligados ao fato de que o usuário final paga diretamente pelo serviço de vídeos, e dois deles (televisão "gratuita" e broadcast de internet) são ligados a remuneração por outras fontes que não seja o espectador final. &hellip;

<p>A taxa de licenciamento para televisão "gratuita" é baseada em uma das duas opções de royalties. A primeiro é um pagamento único de $2,500 por transmissão codificada AVC, que cobre um codificador AVC "usado por ou a favor da licença de transmissão de vídeo AVC para o úsuario final" que é quem irá decodificar e visualizá-lo. Se você está se perguntando se isso é um encargo duplo, a resposta é sim: A taxa da licença já foi cobrada do codificador manufaturado, e o broadcast vai em turnos pagar uma das duas opções de royalties.

<p>A segunda taxa de licenciamento é anual. [A] taxa anual de broadcast é dividida pelo tamanho da audiência:
<ul>
<li>$2,500 por ano por mercado de broadcasts de 100,000–499,999 famílias de televisão
<li>$5,000 por ano por mercado de broadcasts de 500,000–999,999 famílias de televisão
<li>$10,000 por ano por mercado de broadcasts de 1,000,000 ou mais famílias de televisão
</ul>

<p> Com toda a questão da televisão "livre" por que alguém envolvido em entregas não-broadcast se importaria? Como eu mencionei antes, as taxas de participação são aplicáveis para cada entrega de conteúdo. Depois de definir que televisão "livre" significa mais do que apenas "over-the-air", MPEG LA passou a definir as taxas de licenciamento para transferencia na internet via "vídeo AVC que é entregue em todo mundo para um usuário final para que o usuário final não pague pelo direito de receber ou ver". Em outras palavras, qualquer transmissão pública, seja "over-the-air", cabo, satélite, ou internet estão sujeitas a taxas de participação. &hellip;

<p>As taxas são potencialmente mais íngrimes para transmissões pela internet, talvez sabendo que a entrega na internet irá crescer muito mais rápido do que OTA ou televisão "livre" via cabo ou satélite. Adicionando a televisão "livre" as taxas do mercado da transmissão juntas com a taxa adicional. MPEG LA garantirá um indulto durante o tempo da primeira licença, que acaba em 31 de Dez de 2010, e note que "após a primeira licença o royalties não será mais do que equivalente econômico dos royalties pagos durante o mesmo tempo de televisão livre.&#8221;
</blockquote>

<p>A última parte - Sobre a estrutura das taxas para transmissão pela internet - já foi alterada. A <abbr>MPEG-LA</abbr>  recentemente <a href="http://www.mpegla.com/Lists/MPEG%20LA%20News%20List/Attachments/226/n-10-02-02.pdf" title="warning: PDF">anunciou</a> que o streaming de internet não seria cobrado. Que <em>não</em> significa que H.264 é livre de royalties para todos os usuários. Em particular, codificadores ( Como o que processa o upload de vídeo do YouTube ) e codificadores (como o que esta incluso no Microsoft Internet Explorer 9) ainda são assuntos de taxas de licenciamento. Veja <a href=http://shaver.off.net/diary/2010/08/27/free-as-in-smokescreen/>Livre como em uma tema de fumaça</a> para maiores informações.

<p class=a>&#x2767;

<h2 id=miro>Codificando Vídeo com <br>Miro Video Converter</h2>

<p>Existem muitas ferramentas para codificar vídeo, e há muitas opções de codificação de vídeo que afetam sua qualidade. Se você não deseja tomar o tempo para entender nada sobre codificação de vídeo, esta seção é para você.

<p><dfn>Miro Video Converter</dfn> é programa de código aberto para codificação de vídeo em múltiplos formatos com licença GPL. <a href=http://www.mirovideoconverter.com/>Faça aqui o download para Mac OS X ou Windows</a>. Ele suporta todos os formatos de saída mencionados neste capítulo. Não oferece opções além de escolher um arquivo de vídeo e escolher um formato de saída. Pode receber virtualmente qualquer arquivo de vídeo como entrada, incluindo vídeo DV produzidos por filmadoras. Produz uma saída com qualidade razoável com a maioria dos vídeos. Devido a sua falta de opções, se você estiver descontente com a saída, voce não tem mais recursos além de tentar outro programa.

<p>Para começar, Apenas inicie a aplicação Miro Video Converter.

<div class=c>
<p class="legend top">Tela principal do Miro Video Converter<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-01.png alt="Tela principal do Miro Video Converter" width=365 height=445>
</div>

<p>Clique em "Escolher arquivo" e selecione o vídeo que você quer codificar.

<div class=c>
<p class="legend top"> "Escolher arquivo" <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-02.png alt="Conversor Miro Video depois de escolher um arquivo" width=365 height=445>
</div>

<p>O menu dropdown "Escolha um dispositivo ou um formato de vídeo" lista uma variedade de dispositivos e formatos. Para o propósito deste capítulo, nós estamos interessados em três deles.

<ol>
<li><em>WebM (vp8)</em> é video WebM (<a href=#vp8>video VP8</a> e <a href=#vorbis>audio Vorbis </a> em um contêiner WebM).
<li><em>Theora</em> é <a href=#theora>vídeo Theora</a> e <a href=#vorbis>audio Vorbis</a> em um contêiner Ogg. 
<li><em>iPhone</em> é <a href=#h264>Perfil de Linha de base de video H.264</a> e <a href=#aac>AAC audio de baixa-complexidade</a> em um contêiner MP4.
</ol>

<p>Primeiro selecione "WebM".

<div class=c>
<p class="legend top">Escolha a saída WebM<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-03.png alt="Conversor Miro Video: escolhendo formato de saída WebM" width=365 height=445>
</div>

<p>Click no botão "Converter" e o conversor Miro Video vai imediatamente começar a codificar seu vídeo. O arquivo de saida será nomeado <code>ARQUIVOFONTE.webm</code> e vai ser salvo no mesmo diretório do vídeo de origem.

<div class=c>
<p class="legend top">Voce ficará olhando para esta tela<br>por um bom tempo <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-04.png alt="Conversor Miro Video: Processo de codificação WebM" width=365 height=445>
</div>

<p>Uma vez que a codificação for completada, você será mandado de volta para a tela principal. Desta vez, selecione "Theora" na lista de dispositivos e formatos.

<div class=c>
<p class="legend top">Hora do Theora <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-08.png alt="Conversor Miro Video: escolhendo formato de saída Theora" width=365 height=445>
</div>

<p>É isto; aperte o botão de "Converter" novamente para codificar seu vídeo Theora. O vídeo vai ser nomeado <code>ARQUIVOFONTE.theora.ogv</code> e será salvo no mesmo diretório do arquivo de origem.

<div class=c>
<p class="legend top">Hora de tomar um cafézinho<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-09.png alt="Conversor Miro Video: Processo de codificação Theora" width=365 height=445>
</div>

<p>Finalmente, codifique seu vídeo H.264 compatível com iPhone selecionando "iPhone" na lista de dispositivos e formatos.

<div class=c>
<p class="legend top">iPhone, não iPhone 4 <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-05.png alt="Conversor Miro Video: escolhendo formato de saida compativel com Iphone" width=365 height=445>
</div>

<p>Para vídeo compativel com iPhone, o Conversor Miro Video dará a você uma opção de enviar o arquivo codificado para sua biblioteca iTunes. Eu não tenho uma opinião formada se você gostaria de fazer isto, mas isto não é necessário para publicar vídeo na web.

<div class=c>
<p class="legend top">Não envie para o iTunes<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-06.png alt="Conversor Miro Video: Checkbox Envie para o iTunes" width=365 height=445>
</div>

<p>Aperte o botão mágico "Converter" e aguarde. O arquivo codificado será nomeado <code>ARQUIVOFONTE.iphone.mp4</code> e vai ser salvo no mesmo diretório do arquivo de origem.

<div class=c>
<p class="legend top">Faça yoga ou algo parecido<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/miro-07.png alt="Conversor Miro Video: Progresso de codificação H.264" width=365 height=445>
</div>

<p>Você deverá ter três arquivos de vídeo ao lado do seu arquivo de vídeo fonte. Se você estiver satisfeito com a qualidade do vídeo, avance para <a href=#markup>Enfim, a Marcação</a> para ver como montar eles em um único elemento <code>&lt;vídeo></code> que funcione cross-browsers. Se você gostaria de aprender mais sobre outras ferramentas ou codificação de vídeo, leia.

<p class=a>&#x2767;

<h2 id=firefogg>Codificando Vídeo Ogg com Firefogg</h2>

<p>(Nesta seção, eu vou usar "Video Ogg" como abreviação para "Vídeo Theora e Áudio Vorbis em um contêiner Ogg". Esta é a combinação de codecs+contêiners que funcionam nativamente no Mozilla Firefox e Google Chrome.)

<p><dfn>Firefogg</dfn> é uma extensão do Firefox open source, com licença GPL para codificar vídeo Ogg. Para usar isto,  você vai precisar instalar <a href=http://www.getfirefox.com/>Mozilla Firefox</a> 3.5 ou mais recente, e visitar <a href=http://firefogg.org/>firefogg.org</a>.

<p class="legend top">Página inicial do Firefogg <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/firefogg-01.png alt="Página inicial do Firefogg" width=800 height=600>

<p>Clique "Instalar Firefogg." Firefox irá perguntar se você realmente quer autorizar o site a instalar uma extensão. Clique "Permitir" para continuar.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Permitir instalação do Firefogg
<p><img src=i/firefogg-02.png alt="Instalação do software: Firefogg" width=800 height=600>

<p>Firefox vai apresentar a janela de instalação do software padrão. Clique "Instalar" para continuar.
<p class="legend top" style="text-align:center">Instalar Firefogg<span class=arrow>&#x21b7;</span><br></p>
<p class=c><img src=i/firefogg-03.png alt="Janela de instalação de software do Firefox" width=547 height=367>

<p>Clique "Reiniciar Firefox" para completar a instalação.
<p class="legend top" style="text-align:center"><span class=arrow>&#x21b6;</span> Reiniciar Firefox
<p class=c><img src=i/firefogg-04.png alt="Janelas de notificações do Firefox após a instalação" width=520 height=380>

<p>Depois de reiniciar o Firefox, <code>firefogg.org</code> vai confirmar que o Firefogg foi instalado com sucesso.
<p class="legend top">Instalação completada com sucesso <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/firefogg-05.png alt="Página inicial do Firefogg após instalação" width=800 height=600>

<p>Clique "Criar vídeo Ogg" para iniciar o processo de codificação.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Vamos criar um vídeo!
<p><img src=i/firefogg-06.png alt="Firefogg: Criando Video Ogg" width=800 height=600>

<p>Clique "Selecione o arquivo" para selecionar seu vídeo de origem.
<p class="legend top">Selecione seu arquivo de vídeo<span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/firefogg-07.png alt="Firefogg: Selecione o arquivo" width=800 height=600>

<p>Firefogg tem seis "abas":

<ol>
<li>Predefinições. A predefinição padrão é "vídeo web," o que é bom para nosso propósito.
<li>Limite de Codificação. Codificar vídeo pode levar um bom tempo. Quando você estiver começando, talvez você queira codificar apenas partes do seu vídeo (como, os primeiros 30 segundos) até que você encontre uma combinação de configurações que você goste.
<li>Qualidade básica e controle de resolução. Esta é onde estão a maioria das opções importantes.
<li>Metadata. Eu não vou cobrir isto aqui, mas você pode adicionar metadata ao seu codificador de vídeo como título e autor. Provavelmente você tem adicionado metadata a sua coleção de música com iTunes ou algum outro gerenciador de musicas. É a mesma idéia.
<li>Controle avançado de codificação de vídeo. Não mecha com este a menos que saiba o que está fazendo. (Firefogg oferece ajuda interativa na maioria destas opções. Clique no simbolo "i" próximo a cada opção para aprender mais a respeito.)
<li>Controle avançado de codificação de áudio. Novamente, Não mecha com este a menos que saiba o que está fazendo.
</ol>

<p><img src=i/firefogg-08.png alt="Interface principal do Firefogg" width=800 height=600>

<p id=firefogg-options>A única opção que eu vou cobrir estão na tabela "Qualidade básica e controle de resolução". Ela contém todas as opções importantes:

<ul>
<li>Qualidade de Vídeo. Esta medida é feita numa escala de 0 (qualidade mais baixa) à 10 (qualidade mais alta). Números maiores significam maior tamanho de arquivo, então você precisa experimentar para poder determinar qual é a melhor razão entre tamanho e qualidade para as suas necessidades.
<li>Qualidade de Áudio. Esta medida é feita numa escala de -1 (qualidade mais baixa) à 10 (qualidade mais alta). Números maiores significam maior tamanho de arquivo, como as configurações de qualidade de video.
<li>Codec de Vídeo. Este deve sempre ser &#8220;theora.&#8221;
<li>Codec de Áudio. Este deve sempre ser &#8220;vorbis.&#8221;
<li>Largura e Altura do Vídeo. O padrão deste aqui é o tamanho atual de largura e altura do vídeo de origem. Se você quer redimensionar o vídeo durante o encoding, você pode mudar a largura (ou altura) aqui. O Firefogg irá automaticamente reajustará a outra dimensão para manter a proporção original (assim o seu vídeo não terminará achatado ou alongado).
</ul>

<p><img src=i/firefogg-09.png alt="Controle de qualidade e resolução do Firefogg" width=800 height=600>

<p>Neste exemplo, Eu vou redimensionar o vídeo para a metade da largura original. Note como o Firefogg automaticamente ajusta a altura para a proporção correta.
<p class="legend top">Ajuste da largura e altura do video <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/firefogg-10.png alt="Firefogg: ajustando a largura e a altura" width=800 height=600>

<p>Uma vez preenchido todos os botões, clique em &#8220;Salvar Ogg&#8221; para iniciar o processo de codificação. O Firefogg irá mostrar uma janela para que seja preenchido o nome do arquivo de video.
<p class="legend top">&#8220;Salvar Ogg&#8221; <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/firefogg-12.png alt="Firefogg: Salvar Ogg" width=800 height=600>

<p>O Firefogg irá mostrar uma barra de progresso da codificação do video. Tudo que você precisa é esperar (e esperar, e esperar)!
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Progresso do codificação
<p><img src=i/firefogg-13.png alt="Firefogg: Progresso do codificação" width=800 height=600>

<p class=a>&#x2767;

<h2 id=ffmpeg2theora>Codificação em Lotes de Videos Ogg com ffmpeg2theora</h2>

<p>(Como na seção anterior, nesta eu iréi usar "Video Ogg", como encurtamento de "Theora vídeo e áudio Vorbis em um contêiner Ogg" Esta é a combinação de codecs+contêiners que funciona nativamente no Mozilla Firefox e Google Chrome.)

<p>Se você está procurando por uma codificação em lotes de diversos arquivos de vídeo Ogg e você quer automatizar o processo, você definitivamente deveria dar uma olhada no <a href=http://v2v.cc/~j/ffmpeg2theora/>ffmpeg2theora</a>.

<p>O ffmpeg2theora é uma aplicação para codificação de vídeos Ogg de código livre e licensa GPL. Binários pré-compilados estão disponíveis<a href=http://v2v.cc/~j/ffmpeg2theora/download.html> para Mac OS X, Windows, e distribuições Linux modernas</a>. Ele pode pegar virtualmente qualquer tipo de arquivo como entrada, incluindo vídeos DV produzidos por câmeras simples, não profissionais.

<p>Para usar o ffmpeg2theora, você precisará chamá-lo pela linha de comando. (No Mac OS X, abra Aplicações <span class=u>&rarr;</span> Utilitários <span class=u>&rarr;</span> Terminal. No Windows, abra o seu menu Iniciar <span class=u>&rarr;</span> Programas <span class=u>&rarr;</span> Acessórios <span class=u>&rarr;</span> Prompt de Comando.)

<p>O ffmpeg2theora tem diversos parâmetros de linha de comando. (Escreva <code>ffmpeg2theora --help</code> para ler sobre todos eles.) Eu irei focar em apenas três deles.

<ul>
<li><code>--video-quality Q</code>, onde &#8220;Q&#8221; é um número entre 0&ndash;10.
<li><code>--audio-quality Q</code>, onde &#8220;Q&#8221; é um número entre -2&ndash;10.
<li><code>--max_size=WxH</code>, onde &#8220;W&#8221; e &#8220;H&#8221; são a largura e altura máximos que você deseja para o vídeo. (O "x" entre eles é realmente apenas a letra "x".) o ffmpeg2theora irá redimensionar o vídeo proporcionalmente para ajustar a estas dimensões, então o vídeo codificado deverá ser menor que <code>W&times;H<code>. Por exemplo, realizar o codificação de um vídeo 720&times;480 com tamanho máximo <code>--max_size 320x240</code> irá produzir um arquivo que será <code>230&times;213</code>.
</ul>

<p>Assim, aqui está como você deve codificar um vídeo com as mesmas configurações que nós usamos na seção anterior(<a href=#firefogg>codificação com Firefogg</a>).

<pre><samp class=p>you@localhost$ </samp><kbd>ffmpeg2theora --videoquality 5</kbd>
<samp class=p>               </samp><kbd>              --audioquality 1</kbd>
<samp class=p>               </samp><kbd>              --max_size 320x240</kbd>
<samp class=p>               </samp><kbd>              pr6.dv</kbd></pre>

<p>O vídeo codificado será salvo no mesmo diretório do arquivo de vídeo original, com a extensão <code>.ogv</code> adicionada. Você pode especificar um lugar diferente e/ou um nome diferente passando os seguintes parâmetros <code>--output=/path/to/encoded/video</code> para o ffmpeg2theora.

<p class=a>&#x2767;

<h2 id=handbrake-gui>Encoding H.264 Video with HandBrake</h2>

<p>(In this section, I&#8217;m going to use &#8220;H.264 video&#8221; as a shorthand for &#8220;H.264 baseline profile video and AAC low-complexity profile audio in an MPEG-4 container.&#8221; This is the combination of codecs+container that works natively in Safari, in Adobe Flash, on the iPhone, and on Google Android devices.)

<p><a href=#licensing>Licensing issues</a> aside, the easiest way to encode H.264 video is <a href=http://handbrake.fr/>HandBrake</a>. HandBrake is an open source, GPL-licensed application for encoding H.264 video. (It used to do other video formats too, but in the latest version the developers have dropped support for most other formats and are focusing all their efforts on H.264 video.) <a href=http://handbrake.fr/downloads.php>Pre-built binaries are available</a> for Windows, Mac OS X, and modern Linux distributions.

<p>HandBrake comes in two flavors: graphical and command-line. I&#8217;ll walk you through the graphical interface first, then we&#8217;ll see how my recommended settings translate into the command-line version.

<p>After you open the HandBrake application, the first thing to do is select your source video. Click the &#8220;Source&#8221; dropdown button and choose &#8220;Video File&#8221; to select a file. HandBrake can take virtually any video file as input, including DV video produced by consumer-level camcorders.
<p class="legend top">Select your source video <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/handbrake-01.png alt="HandBrake: select source file" width=800 height=600>

<p>HandBrake will complain that you haven&#8217;t set a default directory to save your encoded videos. You can safely ignore this warning, or you can open the options window (under the &#8220;Tools&#8221; menu) and set a default output directory.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Ignore this
<p><img src=i/handbrake-02.png alt="HandBrake: default directory warning" width=800 height=600>

<p>On the right-hand side is a list of presets. Selecting the &#8220;iPhone &amp; iPod Touch&#8221; preset will set most of the options you need.
<p class="legend top">Select iPhone preset <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/handbrake-03.png alt="HandBrake: select iPhone preset" width=800 height=600>

<p>One important option that is off by default is the &#8220;Web optimized&#8221; option. Selecting this option reorders some of the metadata within the encoded video so you can watch the start of the video while the rest is downloading in the background. I highly recommend always checking this option. It does not affect the quality or file size of the encoded video, so there&#8217;s really no reason not to.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Always optimize for web
<p><img src=i/handbrake-04.png alt="HandBrake: select Web Optimized option" width=800 height=600>

<p>In the &#8220;Picture&#8221; tab, you can set the maximum width and height of the encoded video. You should also select the &#8220;Keep Aspect Ratio&#8221; option to ensure that HandBrake doesn&#8217;t smoosh or stretch your video while resizing it.
<p class="legend top">Set width and height <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/handbrake-05.png alt="HandBrake: set width, height, and aspect ratio" width=800 height=600>

<p>In the &#8220;Video&#8221; tab, you can set four important options.

<ul>
<li>Video Codec. Make sure this is &#8220;H.264 (x264)&#8221;
<li id=two-pass-encoding>2-Pass Encoding. If this is checked, HandBrake will run the video encoder twice. The first time, it just analyzes the video, looking for things like color composition, motion, and scene breaks. The second time, it actually encodes the video using the information it learned during the first pass. As you might expect, this takes about twice as long as single-pass encoding, but it results in better video without increasing file size. I always enable two-pass encoding for H.264 video. Unless you&#8217;re building the next YouTube and encoding videos 24 hours a day, you should probably use two-pass encoding too.
<li>Turbo First Pass. Once you enable 2-pass encoding, you can get a little bit of time back by enabling &#8220;turbo first pass.&#8221; This reduces the amount of work done in the first pass (analyzing the video), while only slightly degrading quality. I usually enable this option, but if quality is of the utmost importance to you, you should leave it disabled.
<li>Quality. There are different ways to specify the &#8220;quality&#8221; of your encoded video. You can set a target file size, and HandBrake will do its best to ensure that your encoded video is not larger than that. You can set an average &#8220;bitrate,&#8221; which is the quite literally the number of bits required to store one second worth of encoded video. (It&#8217;s called an &#8220;average&#8221; bitrate because some seconds will require more bits than others.) Or you can specify a constant quality, on a scale of 0 to 100%. Higher numbers will result in better quality but larger files. There is no single right answer for what quality setting you should use.
</ul>

<div class=pf>
<h4>Ask Professor Markup</h4>
<div class=inner>
<blockquote class=note>
<p><span>&#x261E;</span>Q: Can I use two-pass encoding on Ogg video too?<br>
A: Yes, but due to fundamental differences in how the encoder works, <a href=http://en.flossmanuals.net/TheoraCookbook/FFMPEG2Theora>you probably don&#8217;t need to</a>. Two-pass H.264 encoding almost always results in higher quality video. Two-pass Ogg encoding of Ogg video is only useful if you&#8217;re trying to get your encoded video to be a specific file size. (Maybe that is something you&#8217;re interested in, but it&#8217;s not what these examples show, and it&#8217;s probably not worth the extra time for encoding web video.) For best Ogg video quality, <a href=http://hacks.mozilla.org/2009/09/theora-1-1-released/>use the video quality settings, and don&#8217;t worry about two-pass encoding</a>.
</blockquote>
</div>
</div>

<p>In this example, I&#8217;ve chosen an average bitrate of 600 kbps, which is quite high for a 320&times;240 encoded video. (Later in this chapter, I&#8217;ll show you a sample video encoded at 200 kbps.) I&#8217;ve also chosen 2-pass encoding with a &#8220;turbo&#8221; first pass.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Video quality options
<p><img src=i/handbrake-07.png alt="HandBrake: set two-pass encoding option" width=800 height=600>

<p>In the &#8220;Audio&#8221; tab, you probably don&#8217;t need to change anything. If your source video has multiple audio tracks, you might need to select which one you want in the encoded video. If your video is mostly a person talking (as opposed to music or general ambient sounds), you can probably reduce the audio bitrate to 96 kbps or so. Other than that, the defaults you inherited from the &#8220;iPhone&#8221; preset should be fine.
<p class="legend top">Audio quality options <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/handbrake-08.png alt="HandBrake: audio codec" width=800 height=600>

<p>Next, click the &#8220;Browse&#8221; button and choose a directory and filename to save your encoded video.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Set destination filename
<p><img src=i/handbrake-09.png alt="HandBrake: set destination filename" width=800 height=600>

<p>Finally, click &#8220;Start&#8221; to start encoding.
<p class="legend top">Let&#8217;s make some video! <span class=arrow>&#x21b7;</span><br></p>
<p><img src=i/handbrake-10.png alt="HandBrake: start encoding" width=800 height=600>

<p>HandBrake will display some progress statistics while it encodes your video.
<p class="legend top" style="text-align:right"><span class=arrow>&#x21b6;</span> Patience, Grasshopper
<p><img src=i/handbrake-11.png alt="HandBrake: encoding progress" width=800 height=100>

<p class=a>&#x2767;

<h2 id=handbrake-cli>Batch Encoding H.264 Video with HandBrake</h2>

<p>(Just as in the previous section, in this section I&#8217;m going to use &#8220;H.264 video&#8221; as a shorthand for &#8220;H.264 baseline profile video and AAC low-complexity profile audio in an MPEG-4 container.&#8221; This is the combination of codecs+container that works natively in Safari, in Adobe Flash, on the iPhone, and on Google Android devices.)

<p><a href=http://www.handbrake.fr>HandBrake</a> also comes in a command-line edition. As with <a href=#ffmpeg2theora>ffmpeg2theora</a>, the command-line edition of HandBrake offers a dizzying array of options. (Type <code>HandBrakeCLI --help</code> to read about them.) I&#8217;ll focus on just a few:

<ul>
<li><code>--preset "X"</code>, where &#8220;X&#8221; is the name of a HandBrake preset. The preset you want for H.264 web video is called &#8220;iPhone &amp; iPod Touch&#8221;, and it&#8217;s important to put the entire name in quotes.
<li><code>--width W</code>, where &#8220;W&#8221; is the width of your encoded video. HandBrake will automatically adjust the height to maintain the original video&#8217;s proportions.
<li><code>--vb Q</code>, where &#8220;Q&#8221; is the average bitrate (measured in kilobits per second).
<li><code>--two-pass</code>, which enables 2-pass encoding.
<li><code>--turbo</code>, which enables turbo first pass during 2-pass encoding.
<li><code>--input F</code>, where &#8220;F&#8221; is the filename of your source video.
<li><code>--output E</code>, where &#8220;E&#8221; is the destination filename for your encoded video.
</ul>

<p>Here is an example of calling HandBrake on the command line, with command line flags that match the settings we chose <a href=#handbrake-gui>with the graphical version of HandBrake</a>.

<pre><samp class=p>you@localhost$ </samp><kbd>HandBrakeCLI --preset "iPhone &amp; iPod Touch"</kbd>
<samp class=p>               </samp><kbd>             --width 320</kbd>
<samp class=p>               </samp><kbd>             --vb 600</kbd>
<samp class=p>               </samp><kbd>             --two-pass</kbd>
<samp class=p>               </samp><kbd>             --turbo</kbd>
<samp class=p>               </samp><kbd>             --input pr6.dv</kbd>
<samp class=p>               </samp><kbd>             --output pr6.mp4</kbd>
</pre>

<p>From top to bottom, this command runs HandBrake with the &#8220;iPhone &amp; iPod Touch&#8221; preset, resizes the video to 320&times;240, sets the average bitrate to 600 kbps, enables two-pass encoding with a turbo first pass, reads the file <code>pr6.dv</code>, and encodes it as <code>pr6.mp4</code>. Whew!

<p class=a>&#x2767;

<h2 id=webm-cli>Encoding WebM Video with ffmpeg</h2>

<p>WebM is fully supported in <a href=http://www.ffmpeg.org/><code>ffmpeg</code> 0.6 and later</a>. On the command line, run <code>ffmpeg</code> with no parameters and verify that it was compiled with VP8 support:

<pre><samp class=p>you@localhost$ </samp><kbd>ffmpeg</kbd>
<samp>FFmpeg version SVN-r23197, Copyright (c) 2000-2010 the FFmpeg developers
  built on May 19 2010 22:32:20 with gcc 4.4.3
  configuration: --enable-gpl --enable-version3 --enable-nonfree --enable-postproc --enable-pthreads --enable-libfaac --enable-libfaad --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libtheora --enable-libx264 --enable-libxvid --enable-x11grab <mark>--enable-libvorbis</mark> <mark>--enable-libvpx</mark></samp></pre>

<p>If you don&#8217;t see the magic words &#8220;<code>--enable-libvorbis</code>&#8221; and &#8220;<code>--enable-libvpx</code>,&#8221; you don&#8217;t have the right version of <code>ffmpeg</code>. (If you compiled <code>ffmpeg</code> yourself, check to see if you have two versions installed. That&#8217;s fine, they won&#8217;t conflict with each other. You&#8217;ll just need to use the full path of the VP8-enabled version of <code>ffmpeg</code>.)

<p>I&#8217;m going to do <a href=#two-pass-encoding>a two-pass encode</a>. Pass 1 just scans through the input video file (<code>-i pr6.dv</code>) and writes out some statistics to a log file (which will be auto-named <code>pr6.dv-0.log</code>). I specify the video codec with the <code>-vcodec</code> parameter:

<pre><samp class=p>you@localhost$ </samp><kbd>ffmpeg -pass 1 -passlogfile pr6.dv -threads 16  -keyint_min 0 -g 250 -skip_threshold 0 -qmin 1 -qmax 51 -i pr6.dv <mark>-vcodec libvpx</mark> -b 614400 -s 320x240 -aspect 4:3 -an -y NUL</kbd></pre>

<p>Most of the <code>ffmpeg</code> command line has nothing to do with VP8 or WebM. <code>libvpx</code> does support a number of VP8-specific options that you can pass to <code>ffmpeg</code>, but I don&#8217;t yet know how any of them work. Once I find a good explanation of them, I&#8217;ll link it here and incorporate them into the narrative if it&#8217;s worthwhile to do so. 

<p>For the second pass, <code>ffmpeg</code> will read the statistics it wrote during the first pass and actually do the encoding of the video and the audio. It will write out a <code>.webm</code> file.

<pre><samp class=p>you@localhost$ </samp><kbd>ffmpeg -pass 2 -passlogfile pr6.dv -threads 16  -keyint_min 0 -g 250 -skip_threshold 0 -qmin 1 -qmax 51 -i pr6.dv -vcodec libvpx -b 614400 -s 320x240 -aspect 4:3 -acodec libvorbis -y pr6.webm</kbd></pre>

<p>There are five important parameters here:

<ul>
<li><code>-vcodec libvpx</code> specifies that we&#8217;re encoding with the VP8 video codec. WebM always uses VP8 video.
<li><code>-b 614400</code> specifies the bitrate. Unlike other formats, <code>libvpx</code> expects the bitrate in actual bits, not kilobits. If you want a 600 kbps video, multiply 600 by 1024 to get 614400.
<li><code>-s 320x240</code> specifies the target size, width by height.
<li><code>-aspect 4:3</code> specifies the aspect ratio of the video. Standard definition video is usually 4:3, but most high-definition video is 16:9 or 16:10. In my testing, I found that I had to specify this explicitly on the command line, instead of relying on <code>ffmpeg</code> to autodetect it.
<li><code>-acodec libvorbis</code> specifies that we&#8217;re encoding with the Vorbis audio codec. WebM always uses Vorbis audio.
</ul>

<p class=a>&#x2767;

<h2 id=markup>At Last, The Markup</h2>

<p>I&#8217;m pretty sure this was supposed to be an <abbr>HTML</abbr> book. So where&#8217;s the markup?

<p><abbr>HTML5</abbr> gives you two ways to include video on your web page. Both of them involve the <code>&lt;video></code> element. If you only have one video file, you can simply link to it in a <code>src</code> attribute. This is remarkably similar to including an image with an <code>&lt;img src="..."></code> tag.

<p class="legend top" style="margin-left:2em">One video file <span class=arrow>&#x21b7;</span><br></p>
<pre><code>&lt;video <mark>src="pr6.webm"</mark>>&lt;/video></code></pre>

<p>Technically, that&#8217;s all you need. But just like an <code>&lt;img></code> tag, you should always include <code>width</code> and <code>height</code> attributes in your <code>&lt;video></code> tags. The <code>width</code> and <code>height</code> attributes can be the same as the maximum width and height you specified during the encoding process. Don&#8217;t worry if one dimension of the video is a little smaller than that. Your browser will center the video inside the box defined by the <code>&lt;video></code> tag. It won&#8217;t ever be smooshed or stretched out of proportion.

<pre><code>&lt;video src="pr6.webm" <mark>width="320" height="240"</mark>>&lt;/video></code></pre>

<p>By default, the <code>&lt;video></code> element will not expose any sort of player controls. You can create your own controls with plain old <abbr>HTML</abbr>, <abbr>CSS</abbr>, and JavaScript. The <code>&lt;video></code> element has methods like <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#playing-the-media-resource><code>play()</code> and <code>pause()</code></a> and a read/write property called <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-currenttime><code>currentTime</code></a>. There are also read/write <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-volume><code>volume</code></a> and <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-muted><code>muted</code></a> properties. So you really have everything you need to build your own interface.

<p>If you don&#8217;t want to build your own interface, you can tell the browser to display a built-in set of controls. To do this, just include the <code>controls</code> attribute in your <code>&lt;video></code> tag.

<pre><code>&lt;video src="pr6.webm" width="320" height="240" <mark>controls</mark>>&lt;/video></code></pre>

<p>There are two other optional attributes I want to mention before we go any further: <code>preload</code> and <code>autoplay</code>. Don&#8217;t shoot the messenger; let me explain why these are useful. The <code>preload</code> attribute tells the browser that you would like it to start downloading the video file as soon as the page loads. This makes sense if the entire point of the page is to view the video. On the other hand, if it&#8217;s just supplementary material that only a few visitors will watch, then you can set <code>preload</code> to <code>none</code> to tell the browser to minimize network traffic.

<p>Here&#8217;s an example of a video that will start downloading (but not playing) as soon as the page loads:

<pre><code>&lt;video src="pr6.webm" width="320" height="240" <mark>preload</mark>>&lt;/video></code></pre>

<p>And here&#8217;s an example of a video that will <em>not</em> start downloading as soon as the page loads:

<pre><code>&lt;video src="pr6.webm" width="320" height="240" <mark>preload="none"</mark>>&lt;/video></code></pre>

<p>The <code>autoplay</code> attribute does exactly what it sounds like: it tells the browser that you would like it to start downloading the video file as soon as the page loads, <em>and</em> you would like it to start playing the video automatically as soon as possible. Some people love this; some people hate it. But let me explain why it&#8217;s important to have an attribute like this in <abbr>HTML5</abbr>. Some people are going to want their videos to play automatically, even if it annoys their visitors. If <abbr>HTML5</abbr> <em>didn&#8217;t</em> define a standard way to auto-play videos, people would resort to JavaScript hacks to do it anyway. (For example, by calling the video&#8217;s <code>play()</code> method during the window&#8217;s <code>load</code> event.) This would be much harder for visitors to counteract. On the other hand, it&#8217;s a simple matter to add an extension to your browser (or write one, if necessary) to say &#8220;ignore the <code>autoplay</code> attribute, I don&#8217;t ever want videos to play automatically.&#8221;

<p>Here&#8217;s an example of a video that will start downloading and playing as soon as possible after the page loads:

<pre><code>&lt;video src="pr6.webm" width="320" height="240" <mark>autoplay</mark>>&lt;/video></code></pre>

<p>And here is a <a href=http://www.greasespot.net/>Greasemonkey</a> script that you can install in your local copy of Firefox that prevents <abbr>HTML5</abbr> video from playing automatically. It uses the <code>autoplay</code> <abbr>DOM</abbr> attribute defined by <abbr>HTML5</abbr>, which is the JavaScript equivalent of the <code>autoplay</code> attribute in your <abbr>HTML</abbr> markup. [<a href=examples/disable_video_autoplay.user.js>disable_video_autoplay.user.js</a>]

<pre><code>// ==UserScript==
// @name           Disable video autoplay
// @namespace      http://diveintomark.org/projects/greasemonkey/
// @description    Ensures that HTML5 video elements do not autoplay
// @include        *
// ==/UserScript==

var arVideos = document.getElementsByTagName('video');
for (var i = arVideos.length - 1; i >= 0; i--) {
    var elmVideo = arVideos[i];
    <mark>elmVideo.autoplay = false;</mark>
}</code></pre>

<p>But wait a second&hellip; If you&#8217;ve been following along this whole chapter, you don&#8217;t have just one video file; you have three. One is an <code>.ogv</code> file that you created with <a href=#firefogg>Firefogg</a> or <a href=#ffmpeg2theora>ffmpeg2theora</a>. The second is an <code>.mp4</code> file that you created with <a href=#handbrake-gui>HandBrake</a>. The third is a <code>.webm</code> file that you created with <a href=#webm-cli>ffmpeg</a>. <abbr>HTML5</abbr> provides a way to link to all three of them: the <code>&lt;source></code> element. Each <code>&lt;video></code> element can contain more than one <code>&lt;source></code> element. Your browser will go down the list of video sources, in order, and play the first one it&#8217;s able to play.

<p>That raises another question: how does the browser know which video it can play? Well, in the worst case scenario, it loads each of the videos and tries to play them. That&#8217;s a big waste of bandwidth, though. You&#8217;ll save a lot of network traffic if you tell the browser up-front about each video. You do this with the <code>type</code> attribute on the <code>&lt;source></code> element.

<p>Here&#8217;s the whole thing:

<p class="legend top" style="margin-left:2em">Three (!) video files <span class=arrow>&#x21b7;</span><br></p>
<pre><code>&lt;video width="320" height="240" controls>
  &lt;<mark>source src="pr6.mp4"</mark>  type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
  &lt;<mark>source src="pr6.webm"</mark> type='video/webm; codecs="vp8, vorbis"'>
  &lt;<mark>source src="pr6.ogv"</mark>  type='video/ogg; codecs="theora, vorbis"'>
&lt;/video></code></pre>

<p>Let&#8217;s break that down. The <code>&lt;video></code> element specifies the width and height for the video, but it doesn&#8217;t actually link to a video file. Inside the <code>&lt;video></code> element are three <code>&lt;source></code> elements. Each <code>&lt;source></code> element links to a single video file (with the <code>src</code> attribute), and it also gives information about the video format (in the <code>type</code> attribute).

<p>The <code>type</code> attribute looks complicated &mdash; hell, it <em>is</em> complicated. It&#8217;s a combination of three pieces of information: the <a href=#video-containers>container format</a>, the <a href=#video-codecs>video codec</a>, and the <a href=#audio-codecs>audio codec</a>. Let&#8217;s start from the bottom. For the <code>.ogv</code> video file, the container format is Ogg, represented here as <code>video/ogg</code>. (Technically speaking, that&#8217;s the <abbr>MIME</abbr> type for Ogg video files.) The video codec is Theora, and the audio codec is Vorbis. That&#8217;s simple enough, except the format of the attribute value is a little screwy. The value itself has to include quotation marks, which means you&#8217;ll need to use a different kind of quotation mark to surround the entire value.

<pre><code>  &lt;source src="pr6.ogv" <mark>type='video/ogg; codecs="theora, vorbis"'</mark>></code></pre>

<p>WebM is much the same, but with a different MIME type (<code>video/webm</code> instead of <code>video/ogg</code>) and a different video codec (<code>vp8</code> instead of <code>theora</code>) listed within the <code>codecs</code> parameter.

<pre><code>  &lt;source src="pr6.webm" <mark>type='video/webm; codecs="vp8, vorbis"'</mark>></code></pre>

<p>The H.264 video is even more complicated. Remember when I said that both <a href=#h264>H.264 video</a> and <a href=#aac>AAC audio</a> can come in different &#8220;profiles&#8221;? We encoded with the H.264 &#8220;baseline&#8221; profile and the AAC &#8220;low-complexity&#8221; profile, then wrapped it all in an MPEG-4 container. All of that information is included in the <code>type</code> attribute.

<pre><code>  &lt;source src="pr6.mp4" <mark>type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'</mark>></code></pre>

<p>The benefit of going to all this trouble is that the browser will check the <code>type</code> attribute first to see if it can play a particular video file. If a browser decides it can&#8217;t play a particular video, <em>it won&#8217;t download the file</em>. Not even part of the file. You&#8217;ll save on bandwidth, and your visitors will see the video they came for, faster.

<p>If you follow the instructions in this chapter for encoding your videos, you can just copy and paste the <code>type</code> attribute values from this example. Otherwise, you&#8217;ll need to <a href=http://wiki.whatwg.org/wiki/Video_type_parameters>work out the <code>type</code> parameters for yourself</a>.

<div class=pf>
<h4>Professor Markup Says</h4>
<div class=inner>
<blockquote><p>iPads running iOS 3.x had a bug that prevented them from noticing anything but the first video source listed. iOS 4 (a free upgrade for all iPads) fixes this bug. If you want to deliver video to iPad owners who haven&#8217;t yet upgraded to iOS 4, you will need to list your MP4 file first, followed by the free video formats. <em>Sigh.</em>
</blockquote>
</div>
</div>



<p class=a>&#x2767;

<h3 id=video-mime-types>MIME Types Rear Their Ugly Head</h3>

<p>There are so many pieces to the video puzzle, I hesitate to even bring this up. But it&#8217;s important, because a misconfigured web server can lead to endless amounts of frustration as you try to debug why your videos play on your local computer but fail to play when you deploy them to your production site. If you run into this problem, the root cause is probably <abbr>MIME</abbr> types.

<p>I mentioned <abbr>MIME</abbr> types <a href=past.html#mime-types>in the history chapter</a>, but you probably glazed over that and didn&#8217;t appreciate the significance. So here it is in all-caps:

<div class=pf>
<h4>Professor Markup Shouts</h4>
<div class=inner>
<blockquote>
<p>VIDEO FILES MUST BE SERVED WITH THE PROPER <abbr>MIME</abbr> TYPE!
</blockquote>
</div>
</div>

<p>What&#8217;s the proper <abbr>MIME</abbr> type? You&#8217;ve already seen it; it&#8217;s part of the value of the <code>type</code> attribute on a <code>&lt;source></code> element. But setting the <code>type</code> attribute in your <abbr>HTML</abbr> markup is not sufficient. You also need to ensure that your web server includes the proper <abbr>MIME</abbr> type in the <code>Content-Type</code> <abbr>HTTP</abbr> header.

<p>If you&#8217;re using the Apache web server or some derivative of Apache, you can use an <a href=http://httpd.apache.org/docs/2.0/mod/mod_mime.html#addtype>AddType directive</a> in your site-wide <code>httpd.conf</code> or in an <code>.htaccess</code> file in the directory where you store your video files. (If you use some other web server, consult your server&#8217;s documentation on how to set the <code>Content-Type</code> <abbr>HTTP</abbr> header for specific file types.)

<pre><code>AddType video/ogg .ogv
AddType video/mp4 .mp4
AddType video/webm .webm</code></pre>

<p>The first line is for videos in an Ogg container. The second line is for videos in an <abbr>MPEG</abbr>-4 container. The third is for WebM. Set it once and forget it. If you forget to set it, your videos <em>will</em> fail to play in some browsers, even though you included the <abbr>MIME</abbr> type in the <code>type</code> attribute in your <abbr>HTML</abbr> markup.

<p>For even more gory details about configuring your web server, I direct your attention to this excellent article at the Mozilla Developer Center: <a href=https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media>Configuring servers for Ogg media</a>. (The advice in that article applies to MP4 and WebM video, too.)

<p class=a>&#x2767;

<h2 id=ie>What About IE?</h2>

<p>Internet Explorer 9 <a href=http://msdn.microsoft.com/en-us/ie/ff468705.aspx#_HTML5_video_audio>supports the <abbr>HTML5</abbr> <code>&lt;video></code> element</a>, but <a href="http://blogs.msdn.com/ie/archive/2010/03/16/html5-hardware-accelerated-first-ie9-platform-preview-available-for-developers.aspx">Microsoft has publicly promised</a> that the final version of <abbr>IE</abbr> 9 will support H.264 video and AAC audio in an MPEG-4 container, just like Safari and the iPhone.

<p>But what about older versions of Internet Explorer? Like, you know, all shipping versions up to and including <abbr>IE</abbr> 8? Most people who use Internet Explorer also have the Adobe Flash plugin installed. Modern versions of Adobe Flash (starting with 9.0.60.184) support H.264 video and AAC audio in an MPEG-4 container, just like Safari and the iPhone. Once you&#8217;ve <a href=#handbrake-gui>encoded your H.264 video</a> for Safari, you can play it in a Flash-based video player if you detect that one of your visitors doesn&#8217;t have an <abbr>HTML5</abbr>-capable browser.

<p><a href=http://flowplayer.org/>FlowPlayer</a> is an open source, GPL-licensed, Flash-based video player. (<a href=http://flowplayer.org/download/>Commercial licenses are also available</a>.) FlowPlayer doesn&#8217;t know anything about the <code>&lt;video></code> element. It won&#8217;t magically transform a <code>&lt;video></code> tag into a Flash object. But <abbr>HTML5</abbr> is well-designed to handle this, because you can nest an <code>&lt;object></code> element within a <code>&lt;video></code> element. Browsers that don&#8217;t support <abbr>HTML5</abbr> video will ignore the <code>&lt;video></code> element and simply render the nested <code>&lt;object></code> instead, which will invoke the Flash plug-in and play the movie through FlowPlayer. Browsers that support <abbr>HTML5</abbr> video will find a video source they can play and play it, <em>and ignore the nested <code>&lt;object></code> element altogether</em>.

<p>That last bit is the key to the whole puzzle: <abbr>HTML5</abbr> specifies that all elements (other than <code>&lt;source></code> elements) that are children of a <code>&lt;video></code> element must be ignored altogether. That allows you to use <abbr>HTML5</abbr> video in newer browsers and fall back to Flash gracefully in older browsers, without requiring any fancy JavaScript hacks. You can read more about this technique here: <a href=http://camendesign.com/code/video_for_everybody>Video For Everybody</a>.

<p class=a>&#x2767;

<h2 id=ios>Issues on iPhones and iPads</h2>

<p>iOS is Apple&#8217;s operating system that powers iPhones, iPod Touches, and iPads. iOS 3.2 has a number of issues with <abbr>HTML5</abbr> video.

<ol>
<li>iOS will not recognize the video if you include a <code>poster</code> attribute. The <code>poster</code> attribute of the <code>&lt;video></code> element allows you to display a custom image while the video is loading, or until the user presses &#8220;play.&#8221; This bug is fixed in iOS 4.0, but it will be some time before users upgrade.
<li>If you have multiple <code>&lt;source></code> elements, iOS will not recognize anything but the first one. Since iOS devices only support H.264+AAC+MP4, this effectively means you must always list your MP4 first. This bug is also fixed in iOS 4.0.
</ol>

<p class=a>&#x2767;

<h2 id=android>Issues on Android devices</h2>

<p>Android is Google&#8217;s operating system that powers a number of different phones and handheld devices. Versions of Android before 2.3 had a number of issues with <abbr>HTML5</abbr> video.

<ol>
<li>The <code>type</code> attribute on <code>&lt;source></code> elements confused Android greatly. The only way to get it to recognize a video source is, ironically, to omit the <code>type</code> attribute altogether and ensure that your H.264+AAC+MP4 video file&#8217;s name ends with an <code>.mp4</code> extension. You can still include the <code>type</code> attribute on your other video sources, since H.264 is the only video format that Android 2.2 supports. (This bug is fixed in Android 2.3.)
<li>The <code>controls</code> attribute was not supported. There are no ill effects to including it, but Android will not display any user interface controls for a video. You will need to provide your own user interface controls. At a minimum, you should provide a script that starts playing the video when the user clicks the video. This bug is also fixed in Android 2.3.
</ol>

<p class=a>&#x2767;

<h2 id=example>A Complete, Live Example</h2>

<p>Here is a live example of a video that uses these techniques. I extended the &#8220;Video For Everybody&#8221; code to include a WebM-formatted video. I encoded the same source video into three formats, with these commands:

<pre>## Theora/Vorbis/Ogg
<samp class=p>you@localhost$ </samp><kbd>ffmpeg2theora --videobitrate 200 --max_size 320x240 --output pr6.ogv pr6.dv</kbd>

## H.264/AAC/MP4
<samp class=p>you@localhost$ </samp><kbd>HandBrakeCLI --preset "iPhone &amp; iPod Touch" --vb 200 --width 320 --two-pass --turbo --optimize --input pr6.dv --output pr6.mp4</kbd>

## VP8/Vorbis/WebM
<samp class=p>you@localhost$ </samp><kbd>ffmpeg -pass 1 -passlogfile pr6.dv -threads 16  -keyint_min 0 -g 250 -skip_threshold 0 -qmin 1 -qmax 51 -i pr6.dv -vcodec libvpx -b 204800 -s 320x240 -aspect 4:3 -an -f webm -y NUL</kbd>
<samp class=p>you@localhost$ </samp><kbd>ffmpeg -pass 2 -passlogfile pr6.dv -threads 16  -keyint_min 0 -g 250 -skip_threshold 0 -qmin 1 -qmax 51 -i pr6.dv -vcodec libvpx -b 204800 -s 320x240 -aspect 4:3 -acodec libvorbis -ac 2 -y pr6.webm</kbd></pre>

<p>The final markup uses a <code>&lt;video></code> element for <abbr>HTML5</abbr> video, a nested <code>&lt;object></code> element for Flash fallback, and a small bit of script for the benefit of Android devices:

<pre><code>&lt;video id="movie" width="320" height="240" preload controls>
  &lt;source src="pr6.webm" type='video/webm; codecs="vp8, vorbis"' />
  &lt;source src="pr6.ogv" type='video/ogg; codecs="theora, vorbis"' />
  &lt;source src="pr6.mp4" />
  &lt;object width="320" height="240" type="application/x-shockwave-flash"
    data="flowplayer-3.2.1.swf"> 
    &lt;param name="movie" value="flowplayer-3.2.1.swf" /> 
    &lt;param name="allowfullscreen" value="true" /> 
    &lt;param name="flashvars" value='config={"clip": {"url": "http://wearehugh.com/dih5/pr6.mp4", "autoPlay":false, "autoBuffering":true}}' /> 
    &lt;p>Download video as &lt;a href="pr6.mp4">MP4&lt;/a>, &lt;a href="pr6.webm">WebM&lt;/a>, or &lt;a href="pr6.ogv">Ogg&lt;/a>.&lt;/p> 
  &lt;/object>
&lt;/video>
&lt;script>
  var v = document.getElementById("movie");
  v.onclick = function() {
    if (v.paused) {
      v.play();
    } else {
      v.pause();
    }
  };
&lt;/script>
</code></pre>

<p>With the combination of <abbr>HTML5</abbr> and Flash, you should be able to watch this video in almost any browser and device:

<video id="video" width="320" height="240" preload controls> 
  <source src="i/pr6.webm" type='video/webm; codecs="vp8, vorbis"' />
  <source src="i/pr6.ogv" type='video/ogg; codecs="theora, vorbis"' />
  <source src="i/pr6.mp4" />
  <object width="320" height="240" type="application/x-shockwave-flash"
    data="http://releases.flowplayer.org/swf/flowplayer-3.2.1.swf"> 
    <param name="movie" value="http://releases.flowplayer.org/swf/flowplayer-3.2.1.swf" /> 
    <param name="allowfullscreen" value="true" /> 
    <param name="flashvars" value='config={"clip":{"url":"http://diveintohtml5.org/i/pr6.mp4","autoPlay":false,"autoBuffering":true}}' /> 
    <p>Download video as <a href=i/pr6.mp4>MP4</a>, <a href=i/pr6.webm>WebM</a>, or <a href=i/pr6.ogv>Ogg</a>.</p> 
  </object> 
</video> 

<p class=a>&#x2767;

<h2 id=further-reading>Further Reading</h2>

<ul>
<li><a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#video><abbr>HTML5</abbr>: The <code>&lt;video></code> element</a>
<li><a href=http://camendesign.com/code/video_for_everybody>Video for Everybody</a>
<li><a href=http://diveintomark.org/tag/give>A gentle introduction to video encoding</a>
<li><a href=http://hacks.mozilla.org/2009/09/theora-1-1-released/>Theora 1.1 is released &mdash; what you need to know</a>
<li><a href=https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media>Configuring servers for Ogg media</a>
<li><a href=http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-x264.html>Encoding with the <code>x264</code> codec</a>
<li><a href=http://wiki.whatwg.org/wiki/Video_type_parameters>Video type parameters</a>
<li><a href=http://dev.opera.com/articles/view/everything-you-need-to-know-about-html5-video-and-audio/>Everything you need to know about <abbr>HTML5</abbr> audio and video</a>
<li><a href=http://www.broken-links.com/2010/07/08/making-html5-video-work-on-android-phones/>Making <abbr>HTML5</abbr> video work on Android phones</a>. <i>Le sigh.</i>
<li><a href=http://msdn.microsoft.com/en-us/ie/ff468705.aspx#_HTML5_video_audio>Internet Explorer 9 Guide for Developers: HTML5 video and audio elements</a>
</ul>

<p>Pre-built custom controls for HTML5 video:

<ul>
<li><a href=http://videojs.com/>VideoJS</a>
<li><a href=http://mediaelementjs.com/>MediaElement.js</a>
<li><a href=http://www.kaltura.org/project/HTML5_Video_Media_JavaScript_Library>Kaltura HTML5 Video &amp; Media JavaScript Library</a>
</ul>

<p class=a>&#x2767;

<p>This has been &#8220;Video on the Web.&#8221; The <a href=table-of-contents.html>full table of contents</a> has more if you&#8217;d like to keep reading.

<div class=pf>
<h4>Did You Know?</h4>
<div class=moneybags>
<blockquote><p>In association with Google Press, O&#8217;Reilly is distributing this book in a variety of formats, including paper, ePub, Mobi, and <abbr>DRM</abbr>-free <abbr>PDF</abbr>. The paid edition is called &#8220;HTML5: Up &amp; Running,&#8221; and it is available now. This chapter is included in the paid edition.
<p>If you liked this chapter and want to show your appreciation, you can <a href="http://www.amazon.com/HTML5-Up-Running-Mark-Pilgrim/dp/0596806027?ie=UTF8&amp;tag=diveintomark-20&amp;creativeASIN=0596806027">buy &#8220;HTML5: Up &amp; Running&#8221; with this affiliate link</a> or <a href=http://oreilly.com/catalog/9780596806033>buy an electronic edition directly from O&#8217;Reilly</a>. You&#8217;ll get a book, and I&#8217;ll get a buck. I do not currently accept direct donations.
</blockquote>
</div>
</div>

<p class=c>Copyright MMIX&ndash;MMXI <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=017884302975346027366:bgclqh8nvse><input type=hidden name=ie value=UTF-8><input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<script src=j/jquery.js></script>
<script src=j/dih5.js></script>
<script>
  if (navigator.userAgent.toLowerCase().search("android") > -1) {
    $("#video").click(function() {
      if (v.paused) {
        v.play();
      } else {
        v.pause();
      }
    });
  }
</script>
